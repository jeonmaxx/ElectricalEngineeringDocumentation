{"config":{"indexing":"full","lang":["de"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Electrical Engineering Toolbox Documentation Einleitung Dies hier ist eine Dokumentation, die die Benutzung der Elektrotechnik Toolbox erkl\u00e4ren und vereinfachen soll. Momentan beinhaltet die Toolbox Skripte f\u00fcr einen Widerstandsfarbcodekonverter und f\u00fcr einen Leiterbahnbreitenkalkulator. Im Folgenden werden die einzelnen Funktionen gezeigt und erkl\u00e4rt, damit man die Toolbox ohne jegliche Probleme benutzen kann. Projekt Layout Widerstand : Hiermit kann man den Widerstandsfarbcode konvertieren. Sowohl von Wert zu Farbe, als auch von Farbe zu Wert. Leiterbahnbreiten : Hiermit kann man die ben\u00f6tigte Leiterbahnbreite ausrechnen. Zudem beinhaltet es auch Funktionen, mit denen man verschiedene Einheiten umwandeln kann (zum Beispiel Celsius zu Fahrenheit).","title":"Home"},{"location":"#electrical-engineering-toolbox-documentation","text":"","title":"Electrical Engineering Toolbox Documentation"},{"location":"#einleitung","text":"Dies hier ist eine Dokumentation, die die Benutzung der Elektrotechnik Toolbox erkl\u00e4ren und vereinfachen soll. Momentan beinhaltet die Toolbox Skripte f\u00fcr einen Widerstandsfarbcodekonverter und f\u00fcr einen Leiterbahnbreitenkalkulator. Im Folgenden werden die einzelnen Funktionen gezeigt und erkl\u00e4rt, damit man die Toolbox ohne jegliche Probleme benutzen kann.","title":"Einleitung"},{"location":"#projekt-layout","text":"Widerstand : Hiermit kann man den Widerstandsfarbcode konvertieren. Sowohl von Wert zu Farbe, als auch von Farbe zu Wert. Leiterbahnbreiten : Hiermit kann man die ben\u00f6tigte Leiterbahnbreite ausrechnen. Zudem beinhaltet es auch Funktionen, mit denen man verschiedene Einheiten umwandeln kann (zum Beispiel Celsius zu Fahrenheit).","title":"Projekt Layout"},{"location":"resistance/","text":"Widerstandsfarbcode Einleitung In diesem Teil wird die Benutzung, der Widerstand Tools erkl\u00e4rt. Es gibt f\u00fcr die Widerstand Tools momentan drei Klassen. Einmal die Resistor Klasse, die haupts\u00e4chlich die Werte verwaltet. Dann die Factor Klasse, welche den Factorring bearbeitet. Und die Tolerance Klasse, die den Toleranzring bearbeitet. Resistor Zuerst gibt es ein Enum, f\u00fcr die einzelnen Farben der Ringe, welchen man erweitern k\u00f6nnte, falls noch Farben dazu kommen sollten. public enum ResistorRing { Black = 0, Brown = 1, Red = 2, Orange = 3, Yellow = 4, Green = 5, Blue = 6, Purple = 7, Gray = 8, White = 9, Gold = 10, Silver = 11, Pink = 12 } Um den Farbcode von Farben zu Wert zu konvertieren, gibt es momentan zwei Konstruktoren. Einmal f\u00fcr vier Ringe und nat\u00fcrlich auch f\u00fcr Ffuuml;nf Ringe. Als Beispiel wird der f\u00fcr vier Ringe gezeigt: public Resistor(ResistorRing ring1, ResistorRing ring2, ResistorRing factor, ResistorRing tolerance) { InvalidNumber(ring1); InvalidNumber(ring2); _ring1 = ring1; _ring2 = ring2; _factor = new Factor(factor); _tolerance = new Tolerance(tolerance); _ringCount = RingCount.Four; UpdateValueFromColors(); } Bei dieser Funktion muss man angeben, welche Farben die ersten beiden Ringe, der Faktorring und der Toleranzring haben . Zuerst wird gepr\u00fcft, ob die Farben, die man eingetragen hat, auch angenommen werden k\u00f6nnen. Der Factorring wird an die Faktor Klasse und der Toleranzring an die Toleranz Klasse \u00fcbergeben. Dann sagt die Funktion, dass hier nur vier Ringe verwendet werden (Beim anderen Konstruktor sagt er an der Stelle f\u00fcnf Ringe) und zum Schluss wird zum finalen berechnen noch die Funktion \"UpdateValueFromColors\" verwendet. Nat\u00fcrlich gibt es auch einen Konstruktor, wenn man von einem Wert zu Farben konvertieren will: public Resistor(int value, Tolerance tolerance, RingCount ringCount) { _ringCount = ringCount; _tolerance = tolerance; int relevantDigits = value; int cFactor = 0; switch (ringCount) { case RingCount.Four: while (relevantDigits >= 100) { relevantDigits /= 10; cFactor++; } _ring2 = (ResistorRing)(relevantDigits % 10); _ring1 = (ResistorRing)(relevantDigits / 10); break; case RingCount.Five: while (relevantDigits >= 1000) { relevantDigits /= 10; cFactor++; } _ring3 = (ResistorRing)(relevantDigits % 10); _ring2 = (ResistorRing)(relevantDigits / 10 % 10); _ring1 = (ResistorRing)(relevantDigits / 100 % 10); break; default: throw new ArgumentOutOfRangeException(nameof(ringCount), ringCount, null); } _factor = new Factor(Math.Pow(10, cFactor)); UpdateValueFromColors(); } Hierbei muss man angeben, welchen Wert man braucht, welche Toleranz man haben m\u00f6chte und wie viele Ringe der Widerstandsfarbcode haben soll . Dann gibt es einen Switch f\u00fcr beide F\u00e4lle der Ringanzahl, also sowohl f\u00fcr vier, als auch f\u00fcr f\u00fcnf Ringe. Dabei wird der Wert dann gek\u00fcrzt, da nur die ersten beiden, beziehungsweise drei Zahlen wichtig f\u00fcr die Umrechnung sind. Dabei wird der cFaktor bei jedem K\u00fcrzen erh\u00f6ht, damit das Programm bestimmen kann, welche Faktorfarbe ben\u00f6tigt wird. Dann berechnet er die einzelnen Ziffern, der relevanten Zahl, mit der Hilfe von Division und Modulo. So kann er also bestimmen, welche Farbe sowohl der erste, als auch der zweite und ggf. dritte Ring ben\u00f6tigt. Der Faktor wird dann mit Hilfe der Faktor Klasse und cFaktor berechnet und die Toleranz musste man hier selbst bestimmen. Und zu guter Letzt gibt es noch die \"UpdateValueFromColors\" Funktion, welche in allen Konstruktoren f\u00fcr die Umrechnung benutzt wird: private void UpdateValueFromColors() { int tmp = _ringCount switch { RingCount.Four => (int) (_ring2 + 10 * (int) _ring1), RingCount.Five => (int) (_ring3 + 10 * (int) _ring2 + 100 * (int) _ring1), _ => throw new ArgumentOutOfRangeException() }; _value = (long) (tmp * _factor.Value); } Auch hier gibt es wieder eine M\u00f6glichkeit, den Wert f\u00fcr vier, als auch f\u00fcr f\u00fcnf Ringe auszurechnen. Der Wert, der dabei rauskommt wird dann noch mit dem Wert des Faktors multipliziert und schon hat man den ben\u00f6tigten Wert. Factor Die Faktor Klasse hat nur Drei Hauptteile, die relativ simpel und einfach zu erkl\u00e4ren sind. Hier werden zuerst die einzelnen Faktoren aufgelistet, welche auch hier erweiterbar w\u00e4ren, falls noch welche dazu kommen sollten. public static Factor One = new Factor(1); public static Factor Ten = new Factor(10); public static Factor Hundred = new Factor(100); public static Factor Thousand = new Factor(1_000); public static Factor TenThousand = new Factor(10_000); public static Factor HundredThousand = new Factor(100_000); public static Factor Million = new Factor(1_000_000); public static Factor TenMillion = new Factor(10_000_000); public static Factor HundredMillion = new Factor(100_000_000); public static Factor Billion = new Factor(1_000_000_000); public ResistorRing Color { get; } public double Value { get; } Wenn man von Farbe zu Wert rechnen m\u00f6chte, dann kann man das ganz einfach mit dieser Funktion machen, indem man ihr die gew\u00fcnschte Farbe \u00fcbergibt. In dem Switch wird festgelegt, welche Farbe welchen Faktor bekommt und dieser Faktorwert wird dann zur\u00fcckgegeben. public Factor(ResistorRing color) { Color = color; Value = color switch { ResistorRing.Black => 1, ResistorRing.Brown => 10, ResistorRing.Red => 100, ResistorRing.Orange => 1_000, ResistorRing.Yellow => 10_000, ResistorRing.Green => 100_000, ResistorRing.Blue => 1_000_000, ResistorRing.Purple => 10_000_000, ResistorRing.Gray => 100_000_000, ResistorRing.White => 1_000_000_000, ResistorRing.Gold => 0.1, ResistorRing.Silver => 0.01, ResistorRing.Pink => 0.001, _ => throw new ArgumentOutOfRangeException(nameof(color), color, null) }; } Hiermit kann man von Wert zu Farbe rechnen, indem man den Wert \u00fcbergibt. Auch hier wird ein Switch benutzt, um den gew\u00fcnschten Wert in die dazugeh\u00f6rige Farbe umzuwandeln. public Factor(double value) { Value = value; Color = value switch { 1 => ResistorRing.Black, 10 => ResistorRing.Brown, 100 => ResistorRing.Red, 1_000 => ResistorRing.Orange, 10_000 => ResistorRing.Yellow, 100_000 => ResistorRing.Green, 1_000_000 => ResistorRing.Blue, 10_000_000 => ResistorRing.Purple, 100_000_000 => ResistorRing.Gray, 1_000_000_000 => ResistorRing.White, 0.1 => ResistorRing.Gold, 0.01 => ResistorRing.Silver, 0.001 => ResistorRing.Pink, _ => throw new OutOfSpecException() }; } Tolerance Auch hier gibt es wieder einen Enum. Dieser verf\u00fcgt \u00fcber die drei verschiedenen Rundungs-Modi: Abrunden, Aufrunden und zum n\u00e4chsten runden . Danach werden den verschiedenen Toleranzm\u00f6glichkeiten noch ihre jeweilige Ringfarbe zugeteilt. public enum RoundMode { ToLower, ToUpper, Nearest } public static Tolerance One => new Tolerance(ResistorRing.Brown); public static Tolerance Two => new Tolerance(ResistorRing.Red); public static Tolerance Half => new Tolerance(ResistorRing.Green); public static Tolerance Quarter => new Tolerance(ResistorRing.Blue); public static Tolerance Tenth => new Tolerance(ResistorRing.Purple); public static Tolerance Twentieth => new Tolerance(ResistorRing.Gray); public static Tolerance Five => new Tolerance(ResistorRing.Gold); public static Tolerance Ten => new Tolerance(ResistorRing.Silver); public ResistorRing Color { get; private set; } public double Value { get; } Dieser Konstruktor ist daf\u00fcr zust\u00e4ndig, dass wenn man eine Farbe angibt, man den passenden Toleranzwert ausgegeben bekommt. Falls man eine Farbe angeben sollte, f\u00fcr welche es keinen Wert gibt, dann wird eine Exception getriggert, damit daraus keine Fehler entstehen k\u00f6nnen. public Tolerance(ResistorRing ring) { Color = ring; Value = ring switch { ResistorRing.Black => throw new OutOfSpecException(), ResistorRing.Brown => 1, ResistorRing.Red => 2, ResistorRing.Orange => 0.05, ResistorRing.Yellow => 0.02, ResistorRing.Green => 0.5, ResistorRing.Blue => 0.25, ResistorRing.Purple => 0.1, ResistorRing.Gray => 0.01, ResistorRing.White => throw new OutOfSpecException(), ResistorRing.Gold => 5, ResistorRing.Silver => 10, ResistorRing.Pink => throw new OutOfSpecException(), _ => throw new ArgumentOutOfRangeException(nameof(ring), ring, null) }; } Dieser Konstruktor ist f\u00fcr das Kovertieren von Wert zu Farbe zust\u00e4ndig. Zudem muss man auch den Rundungsmodus ausw\u00e4hlen, damit einer der m\u00f6glichen Farben bei der Rechnung als Ergebnis herauskommen kann. Default ist dabei das Abrunden. public Tolerance(double value, RoundMode mode = RoundMode.ToLower) { double[] allowedValues = { 1, 2, 0.5, 0.25, 0.1, 0.01, 5, 10, 0.02, 0.05 }; value = Math.Abs(value); switch (mode) { case RoundMode.ToLower: double lowTargetValue = allowedValues.OrderByDescending(v => v) .SkipWhile(v => v > value) .FirstOrDefault(); Value = lowTargetValue == 0 ? allowedValues.Min() : lowTargetValue; break; case RoundMode.ToUpper: double highTargetValue = allowedValues.OrderBy(v => v) .SkipWhile(v => v < value) .FirstOrDefault(); Value = highTargetValue == 0 ? allowedValues.Max() : highTargetValue; break; case RoundMode.Nearest: Value = allowedValues.Aggregate((x, y) => Math.Abs(x - value) < Math.Abs(y - value) ? x : y); break; default: throw new ArgumentOutOfRangeException(nameof(mode), mode, null); } CalculateColorFromValue(); } Zun\u00e4chst gibt es ein Array, wo alle erlaubten Ergebnisse eingetragen sind. Dieses ist f\u00fcr die folgenden Rechungen n\u00fctzlich. Als n\u00e4chstes folgt ein Switch f\u00fcr die verschiedenen Rundungsmodi. Beim Abrunden werden die erlaubten Zahlen zuerst vom Gr\u00f6\u00dften bis zum Kleinsten sortiert. Allerdings werden dabei nur die Werte beachtet, die kleiner als der angegebene Wert sind. Danach wird der erste von diesen Werten (also der gr\u00f6\u00dfte Wert, von denen die kleiner als der angegebene sind) zu dem Wert von lowTargetValue. Wenn alle erlaubten Werte gr\u00f6\u00dfer als der angegebene Wert sind, dann wird lowTargetValue zu 0. Wenn lowTargetValue 0 ist, wird der kleinste Wert aus dem erlaubten Werte Array genommen, ansonsten bleibt es beim Wert von lowTargetValue. Beim Aufrunden ist es so \u00e4hnlich, nur dass vom Kleinsten bis zum Gr\u00f6\u00dften sortiert wird. Die Werte, welche kleiner als der angegebene Wert sind, werden dabei \u00fcbersprungen und dann wird der kleinste Wert von denen, die gr\u00f6\u00dfer als der angegebene Wert highTargetValue zugewiesen. Wenn dieser Wert auch hier 0 sein sollte, wird highTargetValue zum gr\u00f6\u00dften Wert von den erlaubten Werten. Beim Runden zum N\u00e4chsten wird Aggregate benutzt, um herauszufinden, welcher Wert am n\u00e4chsten an dem angegebenen ist. Dabei wird \u00fcberpr\u00fcft, ob die Differenz zu x oder y kleiner ist. Ist der Abstand zu x kleiner, dann bleibt der x Wert beim n\u00e4chsten Durchlauf x und wenn nicht, dann wird der y Wert zum neuen x Wert. Das geht solange, bis alle Werte vom Array durchgelaufen sind. Der letzte x Wert bleibt dann der Wert von Value und ist somit der n\u00e4chste Wert an dem angegebenen. Hier werden den einzelnen numerischen Werten die jeweilige Farbe zugewiesen, falls man die Farbe durch einen angegebenen Wert ausrechnen m\u00f6chte. private void CalculateColorFromValue() { Color = Value switch { 1 => ResistorRing.Brown, 2 => ResistorRing.Red, 0.5 => ResistorRing.Green, 0.25 => ResistorRing.Blue, 0.1 => ResistorRing.Purple, 0.01 => ResistorRing.Gray, 5 => ResistorRing.Gold, 10 => ResistorRing.Silver, 0.02 => ResistorRing.Yellow, 0.05 => ResistorRing.Orange, _ => throw new ArgumentOutOfRangeException() }; } Testing Durch Tests haben wir \u00fcberpr\u00fcft ob ColorToValue, ValueToColor und die Toleranz Methoden so funktioren, wie sie funktionieren sollten. Dabei haben wir f\u00fcr jeden dieser Testkategorien eine eigene Klasse gemacht, damit es \u00fcbersichtlich bleibt. ColorToValue Test Zuerst haben wir die Methoden getestet, mit denen man von Farbe zu Wert konvertieren kann. Dabei wurde zum einen getestet, was passiert, wenn man eine ung\u00fcltige Farbe eingeben w\u00fcrde. [TestMethod] public void InvalidNummeric() { ResistorRing r = ResistorRing.Red; Resistor RFour = new Resistor(r, r, r, r); Resistor RFive = new Resistor(r, r, r, r, r); } Dann wurde auch direkt getestet, ob das Konvertieren von Farbe zu Faktor vern\u00fcnftig funktioniert und auch keine Fehler auftauchen. [TestMethod] public void ColorToFactor() { ResistorRing[] RingFactor = new ResistorRing[] {ResistorRing.Pink,ResistorRing.Silver,ResistorRing.Gold,ResistorRing.Black, ResistorRing.Brown, ResistorRing.Red,ResistorRing.Orange,ResistorRing.Yellow, ResistorRing.Green,ResistorRing.Blue,ResistorRing.Purple,ResistorRing.Gray,ResistorRing.White, }; double j = 0.001; for (int i = 0; i < RingFactor.Length; i++) { Assert.AreEqual(j, new Factor(RingFactor[i]).Value); j *= 10; } } ValueToColor Test Es wurde auch getestet, ob das Konvertieren von Wert zu Farbe funktioniert. Dabei wurde als erstes getestet, ob die Funktion den Wert richtig rundet. [TestMethod] public void ValueTest() { long test = new Resistor(373500, Tolerance.One, RingCount.Four).Value; Assert.AreEqual(370000, test); } Danach wurde getestet, ob die Konvertierung mit vier Ringen so funktioniert, wie gedacht. [TestMethod] public void FourRingTest() { ResistorRing One = new Resistor(373500, Tolerance.One, RingCount.Four).Ring1; ResistorRing Two = new Resistor(373500, Tolerance.One, RingCount.Four).Ring2; ResistorRing Three = new Factor(1).Color; ResistorRing Four = new Tolerance(One).Color; string fourRings = One.ToString() + \" \" + Two.ToString() + \" \" + Three.ToString() + \" \" + Four.ToString(); string result = \"Orange Purple Black Orange\"; Assert.AreEqual(result, fourRings); } Nat\u00fcrlich wurde das Gleiche auch mit f\u00fcnf Ringen getestet. [TestMethod] public void FiveRingTest() { ResistorRing One = new Resistor(373500, Tolerance.One, RingCount.Five).Ring1; ResistorRing Two = new Resistor(373500, Tolerance.One, RingCount.Five).Ring2; ResistorRing Three = new Resistor(373500, Tolerance.One,RingCount.Five).Ring3; ResistorRing Four = new Factor(1).Color; ResistorRing Five = new Tolerance(One).Color; string fiveRings = One.ToString() + \" \" + Two.ToString() + \" \" + Three.ToString() + \" \" + Four.ToString() + \" \" + Five.ToString(); string result = \"Orange Purple Orange Black Orange\"; Assert.AreEqual(result, fiveRings); } Als n\u00e4chstes wurde \u00fcberpr\u00fcft, ob auch der Faktorring funktioniert und die richtige Farbe ausgibt. [TestMethod] public void FactorRingTest() { int val = Rounding(120); Assert.AreEqual(ResistorRing.Red, new Factor(val).Color); } public int Rounding(int value) { int digits = value.ToString().Length; int newValue = 1; while (digits > 1) { newValue *= 10; digits -= 1; } return newValue; } } Tolerance Test Zum Schluss wurde noch getestet, ob die Toleranzklasse so funktioniert, wie gedacht. Dabei wurden die verschiedenen Rundungsmodi mit verschiedenen Zahlen getestet, um Fehler m\u00f6glichst fr\u00fchzeitig zu erkennen. [TestMethod] public void TestMethod1() { (double input, double expectedValue, Tolerance.RoundMode roundMode)[] testList = { (0.00001, 0.01, Tolerance.RoundMode.ToLower), (0, 0.01, Tolerance.RoundMode.ToLower), (-1, 1, Tolerance.RoundMode.ToLower), (-10_000_000_000, 10, Tolerance.RoundMode.ToLower), (10_000_000_000, 10, Tolerance.RoundMode.ToLower), (3.5,2,Tolerance.RoundMode.ToLower), (0.00001, 0.01, Tolerance.RoundMode.ToUpper), (0, 0.01, Tolerance.RoundMode.ToUpper), (-1, 1, Tolerance.RoundMode.ToUpper), (-10_000_000_000, 10, Tolerance.RoundMode.ToUpper), (10_000_000_000, 10, Tolerance.RoundMode.ToUpper), (3.5,5,Tolerance.RoundMode.ToUpper), (0.00001, 0.01, Tolerance.RoundMode.Nearest), (0, 0.01, Tolerance.RoundMode.Nearest), (-1, 1, Tolerance.RoundMode.Nearest), (-10_000_000_000, 10, Tolerance.RoundMode.Nearest), (10_000_000_000, 10, Tolerance.RoundMode.Nearest), (3.5,5,Tolerance.RoundMode.Nearest) }; foreach((double input, double expectedValue, Tolerance.RoundMode roundMode) in testList) { Assert.AreEqual(expectedValue, new Tolerance(input, roundMode).Value); } }","title":"Widerstand"},{"location":"resistance/#widerstandsfarbcode","text":"","title":"Widerstandsfarbcode"},{"location":"resistance/#einleitung","text":"In diesem Teil wird die Benutzung, der Widerstand Tools erkl\u00e4rt. Es gibt f\u00fcr die Widerstand Tools momentan drei Klassen. Einmal die Resistor Klasse, die haupts\u00e4chlich die Werte verwaltet. Dann die Factor Klasse, welche den Factorring bearbeitet. Und die Tolerance Klasse, die den Toleranzring bearbeitet.","title":"Einleitung"},{"location":"resistance/#resistor","text":"Zuerst gibt es ein Enum, f\u00fcr die einzelnen Farben der Ringe, welchen man erweitern k\u00f6nnte, falls noch Farben dazu kommen sollten. public enum ResistorRing { Black = 0, Brown = 1, Red = 2, Orange = 3, Yellow = 4, Green = 5, Blue = 6, Purple = 7, Gray = 8, White = 9, Gold = 10, Silver = 11, Pink = 12 } Um den Farbcode von Farben zu Wert zu konvertieren, gibt es momentan zwei Konstruktoren. Einmal f\u00fcr vier Ringe und nat\u00fcrlich auch f\u00fcr Ffuuml;nf Ringe. Als Beispiel wird der f\u00fcr vier Ringe gezeigt: public Resistor(ResistorRing ring1, ResistorRing ring2, ResistorRing factor, ResistorRing tolerance) { InvalidNumber(ring1); InvalidNumber(ring2); _ring1 = ring1; _ring2 = ring2; _factor = new Factor(factor); _tolerance = new Tolerance(tolerance); _ringCount = RingCount.Four; UpdateValueFromColors(); } Bei dieser Funktion muss man angeben, welche Farben die ersten beiden Ringe, der Faktorring und der Toleranzring haben . Zuerst wird gepr\u00fcft, ob die Farben, die man eingetragen hat, auch angenommen werden k\u00f6nnen. Der Factorring wird an die Faktor Klasse und der Toleranzring an die Toleranz Klasse \u00fcbergeben. Dann sagt die Funktion, dass hier nur vier Ringe verwendet werden (Beim anderen Konstruktor sagt er an der Stelle f\u00fcnf Ringe) und zum Schluss wird zum finalen berechnen noch die Funktion \"UpdateValueFromColors\" verwendet. Nat\u00fcrlich gibt es auch einen Konstruktor, wenn man von einem Wert zu Farben konvertieren will: public Resistor(int value, Tolerance tolerance, RingCount ringCount) { _ringCount = ringCount; _tolerance = tolerance; int relevantDigits = value; int cFactor = 0; switch (ringCount) { case RingCount.Four: while (relevantDigits >= 100) { relevantDigits /= 10; cFactor++; } _ring2 = (ResistorRing)(relevantDigits % 10); _ring1 = (ResistorRing)(relevantDigits / 10); break; case RingCount.Five: while (relevantDigits >= 1000) { relevantDigits /= 10; cFactor++; } _ring3 = (ResistorRing)(relevantDigits % 10); _ring2 = (ResistorRing)(relevantDigits / 10 % 10); _ring1 = (ResistorRing)(relevantDigits / 100 % 10); break; default: throw new ArgumentOutOfRangeException(nameof(ringCount), ringCount, null); } _factor = new Factor(Math.Pow(10, cFactor)); UpdateValueFromColors(); } Hierbei muss man angeben, welchen Wert man braucht, welche Toleranz man haben m\u00f6chte und wie viele Ringe der Widerstandsfarbcode haben soll . Dann gibt es einen Switch f\u00fcr beide F\u00e4lle der Ringanzahl, also sowohl f\u00fcr vier, als auch f\u00fcr f\u00fcnf Ringe. Dabei wird der Wert dann gek\u00fcrzt, da nur die ersten beiden, beziehungsweise drei Zahlen wichtig f\u00fcr die Umrechnung sind. Dabei wird der cFaktor bei jedem K\u00fcrzen erh\u00f6ht, damit das Programm bestimmen kann, welche Faktorfarbe ben\u00f6tigt wird. Dann berechnet er die einzelnen Ziffern, der relevanten Zahl, mit der Hilfe von Division und Modulo. So kann er also bestimmen, welche Farbe sowohl der erste, als auch der zweite und ggf. dritte Ring ben\u00f6tigt. Der Faktor wird dann mit Hilfe der Faktor Klasse und cFaktor berechnet und die Toleranz musste man hier selbst bestimmen. Und zu guter Letzt gibt es noch die \"UpdateValueFromColors\" Funktion, welche in allen Konstruktoren f\u00fcr die Umrechnung benutzt wird: private void UpdateValueFromColors() { int tmp = _ringCount switch { RingCount.Four => (int) (_ring2 + 10 * (int) _ring1), RingCount.Five => (int) (_ring3 + 10 * (int) _ring2 + 100 * (int) _ring1), _ => throw new ArgumentOutOfRangeException() }; _value = (long) (tmp * _factor.Value); } Auch hier gibt es wieder eine M\u00f6glichkeit, den Wert f\u00fcr vier, als auch f\u00fcr f\u00fcnf Ringe auszurechnen. Der Wert, der dabei rauskommt wird dann noch mit dem Wert des Faktors multipliziert und schon hat man den ben\u00f6tigten Wert.","title":"Resistor"},{"location":"resistance/#factor","text":"Die Faktor Klasse hat nur Drei Hauptteile, die relativ simpel und einfach zu erkl\u00e4ren sind. Hier werden zuerst die einzelnen Faktoren aufgelistet, welche auch hier erweiterbar w\u00e4ren, falls noch welche dazu kommen sollten. public static Factor One = new Factor(1); public static Factor Ten = new Factor(10); public static Factor Hundred = new Factor(100); public static Factor Thousand = new Factor(1_000); public static Factor TenThousand = new Factor(10_000); public static Factor HundredThousand = new Factor(100_000); public static Factor Million = new Factor(1_000_000); public static Factor TenMillion = new Factor(10_000_000); public static Factor HundredMillion = new Factor(100_000_000); public static Factor Billion = new Factor(1_000_000_000); public ResistorRing Color { get; } public double Value { get; } Wenn man von Farbe zu Wert rechnen m\u00f6chte, dann kann man das ganz einfach mit dieser Funktion machen, indem man ihr die gew\u00fcnschte Farbe \u00fcbergibt. In dem Switch wird festgelegt, welche Farbe welchen Faktor bekommt und dieser Faktorwert wird dann zur\u00fcckgegeben. public Factor(ResistorRing color) { Color = color; Value = color switch { ResistorRing.Black => 1, ResistorRing.Brown => 10, ResistorRing.Red => 100, ResistorRing.Orange => 1_000, ResistorRing.Yellow => 10_000, ResistorRing.Green => 100_000, ResistorRing.Blue => 1_000_000, ResistorRing.Purple => 10_000_000, ResistorRing.Gray => 100_000_000, ResistorRing.White => 1_000_000_000, ResistorRing.Gold => 0.1, ResistorRing.Silver => 0.01, ResistorRing.Pink => 0.001, _ => throw new ArgumentOutOfRangeException(nameof(color), color, null) }; } Hiermit kann man von Wert zu Farbe rechnen, indem man den Wert \u00fcbergibt. Auch hier wird ein Switch benutzt, um den gew\u00fcnschten Wert in die dazugeh\u00f6rige Farbe umzuwandeln. public Factor(double value) { Value = value; Color = value switch { 1 => ResistorRing.Black, 10 => ResistorRing.Brown, 100 => ResistorRing.Red, 1_000 => ResistorRing.Orange, 10_000 => ResistorRing.Yellow, 100_000 => ResistorRing.Green, 1_000_000 => ResistorRing.Blue, 10_000_000 => ResistorRing.Purple, 100_000_000 => ResistorRing.Gray, 1_000_000_000 => ResistorRing.White, 0.1 => ResistorRing.Gold, 0.01 => ResistorRing.Silver, 0.001 => ResistorRing.Pink, _ => throw new OutOfSpecException() }; }","title":"Factor"},{"location":"resistance/#tolerance","text":"Auch hier gibt es wieder einen Enum. Dieser verf\u00fcgt \u00fcber die drei verschiedenen Rundungs-Modi: Abrunden, Aufrunden und zum n\u00e4chsten runden . Danach werden den verschiedenen Toleranzm\u00f6glichkeiten noch ihre jeweilige Ringfarbe zugeteilt. public enum RoundMode { ToLower, ToUpper, Nearest } public static Tolerance One => new Tolerance(ResistorRing.Brown); public static Tolerance Two => new Tolerance(ResistorRing.Red); public static Tolerance Half => new Tolerance(ResistorRing.Green); public static Tolerance Quarter => new Tolerance(ResistorRing.Blue); public static Tolerance Tenth => new Tolerance(ResistorRing.Purple); public static Tolerance Twentieth => new Tolerance(ResistorRing.Gray); public static Tolerance Five => new Tolerance(ResistorRing.Gold); public static Tolerance Ten => new Tolerance(ResistorRing.Silver); public ResistorRing Color { get; private set; } public double Value { get; } Dieser Konstruktor ist daf\u00fcr zust\u00e4ndig, dass wenn man eine Farbe angibt, man den passenden Toleranzwert ausgegeben bekommt. Falls man eine Farbe angeben sollte, f\u00fcr welche es keinen Wert gibt, dann wird eine Exception getriggert, damit daraus keine Fehler entstehen k\u00f6nnen. public Tolerance(ResistorRing ring) { Color = ring; Value = ring switch { ResistorRing.Black => throw new OutOfSpecException(), ResistorRing.Brown => 1, ResistorRing.Red => 2, ResistorRing.Orange => 0.05, ResistorRing.Yellow => 0.02, ResistorRing.Green => 0.5, ResistorRing.Blue => 0.25, ResistorRing.Purple => 0.1, ResistorRing.Gray => 0.01, ResistorRing.White => throw new OutOfSpecException(), ResistorRing.Gold => 5, ResistorRing.Silver => 10, ResistorRing.Pink => throw new OutOfSpecException(), _ => throw new ArgumentOutOfRangeException(nameof(ring), ring, null) }; } Dieser Konstruktor ist f\u00fcr das Kovertieren von Wert zu Farbe zust\u00e4ndig. Zudem muss man auch den Rundungsmodus ausw\u00e4hlen, damit einer der m\u00f6glichen Farben bei der Rechnung als Ergebnis herauskommen kann. Default ist dabei das Abrunden. public Tolerance(double value, RoundMode mode = RoundMode.ToLower) { double[] allowedValues = { 1, 2, 0.5, 0.25, 0.1, 0.01, 5, 10, 0.02, 0.05 }; value = Math.Abs(value); switch (mode) { case RoundMode.ToLower: double lowTargetValue = allowedValues.OrderByDescending(v => v) .SkipWhile(v => v > value) .FirstOrDefault(); Value = lowTargetValue == 0 ? allowedValues.Min() : lowTargetValue; break; case RoundMode.ToUpper: double highTargetValue = allowedValues.OrderBy(v => v) .SkipWhile(v => v < value) .FirstOrDefault(); Value = highTargetValue == 0 ? allowedValues.Max() : highTargetValue; break; case RoundMode.Nearest: Value = allowedValues.Aggregate((x, y) => Math.Abs(x - value) < Math.Abs(y - value) ? x : y); break; default: throw new ArgumentOutOfRangeException(nameof(mode), mode, null); } CalculateColorFromValue(); } Zun\u00e4chst gibt es ein Array, wo alle erlaubten Ergebnisse eingetragen sind. Dieses ist f\u00fcr die folgenden Rechungen n\u00fctzlich. Als n\u00e4chstes folgt ein Switch f\u00fcr die verschiedenen Rundungsmodi. Beim Abrunden werden die erlaubten Zahlen zuerst vom Gr\u00f6\u00dften bis zum Kleinsten sortiert. Allerdings werden dabei nur die Werte beachtet, die kleiner als der angegebene Wert sind. Danach wird der erste von diesen Werten (also der gr\u00f6\u00dfte Wert, von denen die kleiner als der angegebene sind) zu dem Wert von lowTargetValue. Wenn alle erlaubten Werte gr\u00f6\u00dfer als der angegebene Wert sind, dann wird lowTargetValue zu 0. Wenn lowTargetValue 0 ist, wird der kleinste Wert aus dem erlaubten Werte Array genommen, ansonsten bleibt es beim Wert von lowTargetValue. Beim Aufrunden ist es so \u00e4hnlich, nur dass vom Kleinsten bis zum Gr\u00f6\u00dften sortiert wird. Die Werte, welche kleiner als der angegebene Wert sind, werden dabei \u00fcbersprungen und dann wird der kleinste Wert von denen, die gr\u00f6\u00dfer als der angegebene Wert highTargetValue zugewiesen. Wenn dieser Wert auch hier 0 sein sollte, wird highTargetValue zum gr\u00f6\u00dften Wert von den erlaubten Werten. Beim Runden zum N\u00e4chsten wird Aggregate benutzt, um herauszufinden, welcher Wert am n\u00e4chsten an dem angegebenen ist. Dabei wird \u00fcberpr\u00fcft, ob die Differenz zu x oder y kleiner ist. Ist der Abstand zu x kleiner, dann bleibt der x Wert beim n\u00e4chsten Durchlauf x und wenn nicht, dann wird der y Wert zum neuen x Wert. Das geht solange, bis alle Werte vom Array durchgelaufen sind. Der letzte x Wert bleibt dann der Wert von Value und ist somit der n\u00e4chste Wert an dem angegebenen. Hier werden den einzelnen numerischen Werten die jeweilige Farbe zugewiesen, falls man die Farbe durch einen angegebenen Wert ausrechnen m\u00f6chte. private void CalculateColorFromValue() { Color = Value switch { 1 => ResistorRing.Brown, 2 => ResistorRing.Red, 0.5 => ResistorRing.Green, 0.25 => ResistorRing.Blue, 0.1 => ResistorRing.Purple, 0.01 => ResistorRing.Gray, 5 => ResistorRing.Gold, 10 => ResistorRing.Silver, 0.02 => ResistorRing.Yellow, 0.05 => ResistorRing.Orange, _ => throw new ArgumentOutOfRangeException() }; }","title":"Tolerance"},{"location":"resistance/#testing","text":"Durch Tests haben wir \u00fcberpr\u00fcft ob ColorToValue, ValueToColor und die Toleranz Methoden so funktioren, wie sie funktionieren sollten. Dabei haben wir f\u00fcr jeden dieser Testkategorien eine eigene Klasse gemacht, damit es \u00fcbersichtlich bleibt. ColorToValue Test Zuerst haben wir die Methoden getestet, mit denen man von Farbe zu Wert konvertieren kann. Dabei wurde zum einen getestet, was passiert, wenn man eine ung\u00fcltige Farbe eingeben w\u00fcrde. [TestMethod] public void InvalidNummeric() { ResistorRing r = ResistorRing.Red; Resistor RFour = new Resistor(r, r, r, r); Resistor RFive = new Resistor(r, r, r, r, r); } Dann wurde auch direkt getestet, ob das Konvertieren von Farbe zu Faktor vern\u00fcnftig funktioniert und auch keine Fehler auftauchen. [TestMethod] public void ColorToFactor() { ResistorRing[] RingFactor = new ResistorRing[] {ResistorRing.Pink,ResistorRing.Silver,ResistorRing.Gold,ResistorRing.Black, ResistorRing.Brown, ResistorRing.Red,ResistorRing.Orange,ResistorRing.Yellow, ResistorRing.Green,ResistorRing.Blue,ResistorRing.Purple,ResistorRing.Gray,ResistorRing.White, }; double j = 0.001; for (int i = 0; i < RingFactor.Length; i++) { Assert.AreEqual(j, new Factor(RingFactor[i]).Value); j *= 10; } } ValueToColor Test Es wurde auch getestet, ob das Konvertieren von Wert zu Farbe funktioniert. Dabei wurde als erstes getestet, ob die Funktion den Wert richtig rundet. [TestMethod] public void ValueTest() { long test = new Resistor(373500, Tolerance.One, RingCount.Four).Value; Assert.AreEqual(370000, test); } Danach wurde getestet, ob die Konvertierung mit vier Ringen so funktioniert, wie gedacht. [TestMethod] public void FourRingTest() { ResistorRing One = new Resistor(373500, Tolerance.One, RingCount.Four).Ring1; ResistorRing Two = new Resistor(373500, Tolerance.One, RingCount.Four).Ring2; ResistorRing Three = new Factor(1).Color; ResistorRing Four = new Tolerance(One).Color; string fourRings = One.ToString() + \" \" + Two.ToString() + \" \" + Three.ToString() + \" \" + Four.ToString(); string result = \"Orange Purple Black Orange\"; Assert.AreEqual(result, fourRings); } Nat\u00fcrlich wurde das Gleiche auch mit f\u00fcnf Ringen getestet. [TestMethod] public void FiveRingTest() { ResistorRing One = new Resistor(373500, Tolerance.One, RingCount.Five).Ring1; ResistorRing Two = new Resistor(373500, Tolerance.One, RingCount.Five).Ring2; ResistorRing Three = new Resistor(373500, Tolerance.One,RingCount.Five).Ring3; ResistorRing Four = new Factor(1).Color; ResistorRing Five = new Tolerance(One).Color; string fiveRings = One.ToString() + \" \" + Two.ToString() + \" \" + Three.ToString() + \" \" + Four.ToString() + \" \" + Five.ToString(); string result = \"Orange Purple Orange Black Orange\"; Assert.AreEqual(result, fiveRings); } Als n\u00e4chstes wurde \u00fcberpr\u00fcft, ob auch der Faktorring funktioniert und die richtige Farbe ausgibt. [TestMethod] public void FactorRingTest() { int val = Rounding(120); Assert.AreEqual(ResistorRing.Red, new Factor(val).Color); } public int Rounding(int value) { int digits = value.ToString().Length; int newValue = 1; while (digits > 1) { newValue *= 10; digits -= 1; } return newValue; } } Tolerance Test Zum Schluss wurde noch getestet, ob die Toleranzklasse so funktioniert, wie gedacht. Dabei wurden die verschiedenen Rundungsmodi mit verschiedenen Zahlen getestet, um Fehler m\u00f6glichst fr\u00fchzeitig zu erkennen. [TestMethod] public void TestMethod1() { (double input, double expectedValue, Tolerance.RoundMode roundMode)[] testList = { (0.00001, 0.01, Tolerance.RoundMode.ToLower), (0, 0.01, Tolerance.RoundMode.ToLower), (-1, 1, Tolerance.RoundMode.ToLower), (-10_000_000_000, 10, Tolerance.RoundMode.ToLower), (10_000_000_000, 10, Tolerance.RoundMode.ToLower), (3.5,2,Tolerance.RoundMode.ToLower), (0.00001, 0.01, Tolerance.RoundMode.ToUpper), (0, 0.01, Tolerance.RoundMode.ToUpper), (-1, 1, Tolerance.RoundMode.ToUpper), (-10_000_000_000, 10, Tolerance.RoundMode.ToUpper), (10_000_000_000, 10, Tolerance.RoundMode.ToUpper), (3.5,5,Tolerance.RoundMode.ToUpper), (0.00001, 0.01, Tolerance.RoundMode.Nearest), (0, 0.01, Tolerance.RoundMode.Nearest), (-1, 1, Tolerance.RoundMode.Nearest), (-10_000_000_000, 10, Tolerance.RoundMode.Nearest), (10_000_000_000, 10, Tolerance.RoundMode.Nearest), (3.5,5,Tolerance.RoundMode.Nearest) }; foreach((double input, double expectedValue, Tolerance.RoundMode roundMode) in testList) { Assert.AreEqual(expectedValue, new Tolerance(input, roundMode).Value); } }","title":"Testing"},{"location":"traceWidths/","text":"Leiterbahnbreiten Einleitung In diesem Teil wird die Benutzung, der Leiterbahnbreiten Tools erkl\u00e4rt. Um die verschiedenen Einheiten und Gr\u00f6\u00dfen zu verwalten wurde ein Unit Tree benutzt, damit eine gute Performance gew\u00e4hrleistet werden kann. Desweiteren wird die Calculator Klasse benutzt, um die Ergebniseinheiten zu verwalten. UnitTree Als erstes besitzt der Unit Tree ein Enum, welches alle vorhandenen SI-Pr\u00e4fixe enth\u00e4lt. Diese w\u00e4ren nat\u00fcrlich erweiterbar, falls jemals welche dazu kommen sollten. Zudem besitzt das Enum einen Default, da die Pr\u00e4fixe nicht immer ben\u00f6tigt werden. public enum SIPrefix { Quetta = 30, Ronna = 27, Yotta = 24, Zetta = 21, Exa = 18, Peta = 15, Tera = 12, Giga = 9, Mega = 6, Kilo = 3, Hekto = 2, Deka = 1, SIDefault = 0, Dezi = -1, Zenti = -2, Milli = -3, Mikro = -6, Nani = -9, Piko = -12, Femto = -15, Atto = -18, Zepto = -21, Yokto = -24, Ronto = -27, Quekto = -30 } Danach beginnt auch schon der Unit Tree mit einer Klasse f\u00fcr die Nodes . Die Klasse besitzt zum einem einen String mit der Unit und auch der Parent Unit. Ein Node besteht dabei immer aus einer Unit und dessen Parent Unit. private class Node { public readonly string Unit; public readonly Node? ParentUnit; public Node(string unit, Node? parentUnit) { Unit = unit; ParentUnit = parentUnit; } public override string ToString() { return Unit; } public bool HasUnit(string unit) { return unit == Unit; } } Nach der Node Klasse, folgt die BackTraceNode Klasse. Diese ist vorallem wichtig, um zu \u00fcberpr\u00fcfen, ob der Unit Tree funktioniert. Sie besteht aus einem String, welcher die aktuelle Unit beinhaltet und einer Liste mit den Parent Units. private class BackTraceNode { public readonly string Unit; public List<Node> ParentUnits; public BackTraceNode(string unit) { Unit = unit; } public override string ToString() { return Unit; } public bool HasUnit(string unit) { return unit == Unit; } } Als n\u00e4chstes folgt eine Methode, f\u00fcr die Konvertierung der SI-Pr\u00e4fixe . Sie ben\u00f6tigt die Start und Ziel Unit sowie den Start und Target Pr\u00e4fix. Zudem muss auch ein Wert angegeben werden. Dann werden die Start und Ziel Unit an ConvertValue \u00fcbergeben. Der angegebene Wert wird dann mit 10 StartPr\u00e4fix und 10 ZielPr\u00e4fix multipliziert und auch an ConvertValue \u00fcbergeben. public double ConvertSIPrefixValue(string startUnit, SIPrefix startPrefix, string targetUnit, SIPrefix targetPrefix, double value) { return ConvertValue(startUnit, targetUnit, value * Math.Pow(10.0, (double) startPrefix)) * Math.Pow(10.0, (double) targetPrefix); } Hier ist eine Methode, welche dann den Wert konvertiert . public double ConvertValue(string startUnit, string targetUnit, double value) { IsFunctional(); if (startUnit.Equals(targetUnit)) { return value; } if (_conversion.ContainsKey((startUnit,targetUnit))) { return _conversion[(startUnit, targetUnit)].Invoke(value); } Stack<ConversionFunction> functionStack = CreateConversionStack(startUnit, targetUnit); while (functionStack.Count > 0) { value = functionStack.Pop().Invoke(value); Console.WriteLine(value); } return value; } Zuerst wird gepr\u00fcft, ob der Unit Tree auch funktioniert. Wenn die Start Unit gleich die Ziel Unit ist, dann wird der Wert direkt ausgegeben. Dann wird gepr\u00fcft, ob die Start und Ziel Unit bereits in _conversion vorhanden sind. Danach wird ein functionStack gemacht, mit der Start und Ziel Unit. Solange dieser Stack gr\u00f6\u00dfer als 0 ist, wird das oberste Element vom Stack ausgegeben. Hier wird viel mit dem Unit Tree gearbeitet, um von der Start Unit zur Ziel Unit zu gelangen. Stack<ConversionFunction> CreateConversionStack(string startUnit, string targetUnit) { Queue<Node> openQueue = new Queue<Node>(); List<Node> closedList = new List<Node>(); HashSet<string> processedUnits = new HashSet<string>(); openQueue.Enqueue(new Node(startUnit, null)); processedUnits.Add(startUnit); while (!_conversion.ContainsKey((openQueue.Peek().Unit, targetUnit))) { Node currentItem = openQueue.Dequeue(); closedList.Add(currentItem); foreach (var y in _conversion.Keys.Where(x => x.from == currentItem.ToString())) { if (!processedUnits.Contains(y.to)) { openQueue.Enqueue(new Node(y.to, currentItem)); processedUnits.Add(y.to); } } } closedList.Add(openQueue.Peek()); Stack<ConversionFunction> functionStack = new Stack<ConversionFunction>(); Node currentNode = new Node(targetUnit, openQueue.Peek()); while (currentNode.ParentUnit != null) { Console.WriteLine(currentNode.Unit); functionStack.Push(_conversion[(currentNode.ParentUnit.Unit, currentNode.Unit)]); currentNode = currentNode.ParentUnit; } return functionStack; } Zuerst wird eine Queue f\u00fcr die Openlist und eine List f\u00fcr die Closedlist angelegt. Noch dazu kommt ein HashSet f\u00fcr die bearbeiteten Units (ProcessedUnits). Angefangen wird damit, dass der Openlist die Start Unit hinzugef\u00fcgt wird. Die Parent Unit ist dabei nat\u00fcrlich Null, da die Start Unit in der Regel kein Parent hat. An ProcessedUnits wird die Start Unit auch \u00fcbergeben. Solange _conversion nicht die oberste Unit der Openlist und die Ziel Unit beinhaltet, bekommt currentItem die oberste Unit aus der Openlist , welches gleichzeitig aus der Liste entfernt wird. Die Unit von currentItem kommt dann in die Closedlist . F\u00fcr jedes Element in _conversion wo, x.from das currentItem ist, wird gepr\u00fcft, ob die processedUnits y.to nicht beinhalten. Falls dies der Fall sein sollte, wird der Openlist y.to und currentItem hinzugef\u00fcgt. ProcessedUnits wird auch y.to hizugef\u00fcgt. Danach wird der Closedlist die oberste Unit der Openlist hinzugef\u00fcgt und es wird der functionStack erstellt. Zudem kommt eine neue Node, die currentNode, welche die Ziel Unit und das oberste Element der Openlist beinhaltet. Solange die Parent Unit der currentNode nicht Null ist, wird die currentNode Unit ausgegeben. Der functionStack bekommt oben drauf noch _conversion mit der Parent Unit von currentNode und die Unit von currentNode. Danach bekommt die neue currentNode die Unit von der vorherigen Parent Unit zugewiesen. Zum Schluss wird noch der functionStack zur\u00fcckgegeben. Bei AddPath werden Pfade dem Unit Tree hinzugef\u00fcgt. Solange dies passiert, fuktioniert der Unit Tree nicht, weshalb _functional auch false ist. Hierbei wird _conversion die Start und Ziel Unit und conversionFunc \u00fcbergeben. public void AddPath(string startUnit, string targetUnit, ConversionFunction conversionFunc) { _functional = false; _conversion.TryAdd((startUnit,targetUnit), conversionFunc); } Zum Schluss wird noch \u00fcberpr\u00fcft, ob der Unit Tree funktioniert , damit m\u00f6gliche Fehler fr\u00fchzeitig erkannt werden. private void checkFunctionality() { Dictionary<string,List<string>?> traceBook= new Dictionary<string,List<string>>(); Queue<string> openNodes = new Queue<string>(); traceBook.Add(_conversion.First().Key.from,null); openNodes.Enqueue(_conversion.First().Key.from); do { foreach (var y in _conversion.Keys.Where(x => x.from == openNodes.Peek())) { if (!traceBook.ContainsKey(y.to)) { traceBook.Add(y.to,new List<string>(){y.from}); openNodes.Enqueue(y.to); } else if (traceBook[y.to] != null) { traceBook[y.to].Add(y.from); } else if (traceBook[y.from] != null) { Queue<string> backTrace = new Queue<string>(); foreach (string parent in traceBook[y.from]) { if (traceBook[parent] != null) backTrace.Enqueue(parent); } traceBook[y.from] = null; while (backTrace.Count > 0) { foreach (string parent in traceBook[backTrace.Peek()]) { if (traceBook[parent] != null) backTrace.Enqueue(parent); } traceBook[backTrace.Dequeue()] = null; } } } openNodes.Dequeue(); } while (openNodes.Count > 0); if (traceBook.Count(x => x.Value != null) > 0 || traceBook.Count < _conversion.DistinctBy(y => y.Key.from).Count()) { _functional = false; } else { _functional = true; } } Dabei wird zuerst das Dictionary tracebook und eine Queue mit den noch unbearbeiteten Nodes (openNodes) angelegt. Zum tracebook wird zuerst das erste Element 'from' von _conversion und Null hinzugef\u00fcgt. Bei OpenNodes wird dieses erste Element auch hinzugef\u00fcgt. Danach wird, solange etwas in openNodes vorhanden ist, f\u00fcr jedes Element in _conversion wo x.from gleich das oberste Element von openNodes gepr\u00fcft, ob tracebook y.to nicht beinhaltet. Wenn das der Fall sein sollte, dann wird y.to und eine Liste mit y.from dem tracebook hinzugef\u00fcgt. Ansonsten, wenn y.to vom tracebook nicht gleich Null ist, wird zu y.to vom tracebook y.from hinzugef\u00fcgt. Und wenn y.from vom tracebook nicht gleich Null ist, dann wird eine neue Queue mit dem Namen backtrace angelegt. F\u00fcr jeden parent in backtrace wird \u00fcberpr\u00fcft, ob dieser Null ist. Wenn dies nicht der Fall sein sollte, dann wird dieser parent dem tracebook hinzugef\u00fcgt. Danach wird y.from vom tracebook wieder auf Null gesetzt. Solange in backtrace noch Elemente vorhanden sind, wird vom obersten Element in backtrace gepr\u00fcft ob der parent vom tracebook gleich Null ist. Sollte dies nicht der Fall sein, dann wird der parent dem backtrace hinzugef\u00fcgt. Danach werden das backtrace und die openNodes noch geleert. Zum Schluss wird noch gepr\u00fcft, ob die Anzahl an Values aus dem tracebook, welche nicht gleich Null sind gr\u00f6\u00dfer als 0 sind oder ob das tracebook weniger Elemente als _conversion y.from Elemente hat. Wenn eine der beiden Bedingungen stimmen sollte, dann wird der Unit Tree nicht funktionieren. Wenn das bool _functional false sein sollte, dann wird der Unit Tree gepr\u00fcft, um zu schauen, ob es wirklich false ist. Wenn das bool dann immer noch false sein sollte, dann wird einem in der Konsole deutlich gezeigt, dass etwas nicht ganz funktioniert. public bool IsFunctional() { if (!_functional) { checkFunctionality(); } if (!_functional) { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine(\"!!!Using not functional UnitTree!!!\"); Console.ResetColor(); } return _functional; } Calculator Au\u00dferdem gibt es eine Klasse, die die einzelnen Einheiten der Ergebnisse vom Kalkulator verwaltet. Dazu geh\u00f6ren sowohl die ben\u00f6tigte Fl\u00e4che der inneren Schicht als auch der \u00e4u\u00dferen Schicht. public double CalculateAreaIntern(double ampere, double tRise) { double I = ampere; double TRise = tRise; const double constantK = 0.024; double constantB = 0.44; double constantC = 0.725; double area; area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC)); return area; } public double CalculateAreaExtern(double ampere, double tRise) { double I = ampere; double TRise = tRise; double constantK = 0.048; double constantB = 0.44; double constantC = 0.725; double area; area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC)); return area; } Und nat\u00fcrlich auch f\u00fcr die Breite der Leiterbahnen . Einmal wird dabei mit Mil gerechnet und einmal mit Oz/Ft 2 . public double CalculateWidthMil(double area, double thickness) { double A = area; double t = thickness; double width; width = A / t; return width; } public double CalculateWidthOzFt(double area, double thickness) { return CalculateWidthMil(area, thickness * 1.378f); } Hier wird dann direkt \u00fcberpr\u00fcft, ob der eingegebene Wert verwendet werden kann oder ob dieser nicht erlaubt ist. public bool CheckInputValue(double ampereValue, double temperatureValue, double ThicknessValue, double traceLengthValue, double temperaturRiseValue) { double[] InputValue = { ampereValue, temperatureValue, ThicknessValue, traceLengthValue, temperaturRiseValue }; if(InputValue.Any(x => x <= 0)) { return false; } return true; } Als n\u00e4chstes wird auch \u00fcberpr\u00fcft, ob die eingegebene Unit zul\u00e4ssig ist. Falls dies nicht der Fall sein sollte, dann gibt das Bool false aus. public bool CheckInputUnit(double targetUnitTemperature, double targetUnitThickness, double targetUnitTraceLength, double targetUnitTemperaturRise, double targetUnitWidthIntern, double targetUnitWidthExtern) { int tempResult = 0; int tempRiseResult = 0; int thickResult = 0; int traceLenghtResult = 0; int widthInternResult = 0; int widthExternResult = 0; if (targetUnitTemperature > 0 && targetUnitThickness < 2 && targetUnitTemperaturRise > 0 && targetUnitTemperaturRise < 2) { tempResult = 1; tempRiseResult = 1; } if (targetUnitThickness > 0 && targetUnitThickness < 4) { thickResult = 1; } if(targetUnitTraceLength > 0 && targetUnitTraceLength < 7) { traceLenghtResult = 1; } if(targetUnitWidthIntern > 0 && targetUnitWidthIntern < 3 && targetUnitWidthExtern > 0 && targetUnitWidthExtern < 3) { widthInternResult = 1; widthExternResult = 1; } double[] UnitCheck = { tempResult, tempRiseResult, thickResult, traceLenghtResult, widthInternResult, widthExternResult }; if (UnitCheck.Any(x => x < 1)) { return false; } return true; } Testing Um sicher zu stellen, dass alles funktioniert, haben wir mit Unit Tests verschiedene Methoden und Klassen getestet. Zum einen wurden der Kalkulator sowie die Pr\u00e4fixe getestet und es wurden Tests mit verschiedenen Zahlen gemacht. Zudem wird zus\u00e4tzlich \u00fcberpr\u00fcft, ob der Unit Tree funktioniert, da dieser eins der wichtigsten Elemente der Klasse ist. Calculator Test Um den Unit Tree zu testen gibt es viele Funktionen, um sicher zu stellen, dass keine Fehler auftauchen k\u00f6nnen. Zuerst wird \u00fcberpr\u00fcft, ob die Konvertierung der Einheiten funktioniert. Dabei werden alle Einheiten benutzt, um alle M\u00f6glichkeiten zu \u00fcberpr\u00fcfen. [TestMethod] public void CheckSelfConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"cm\", \"mym\", x => x * 10000); Converter.AddPath(\"cm\", \"mm\", x => x * 10.0); Converter.AddPath(\"cm\", \"m\", x => x / 100.0); Converter.AddPath(\"cm\", \"in\", x => x / 2.54); Converter.AddPath(\"cm\", \"ft\", x => x / 30.48); Converter.AddPath(\"mym\", \"cm\", x => x / 10000); Converter.AddPath(\"m\", \"cm\", x => x * 100.0); Converter.AddPath(\"mm\", \"cm\", x => x / 10.0); Converter.AddPath(\"in\", \"cm\", x => x * 2.54); Converter.AddPath(\"ft\", \"cm\", x => x * 30.48); Converter.AddPath(\"mil\", \"in\", x => x / 1000); Converter.AddPath(\"in\", \"mil\", x => x * 1000); Converter.AddPath(\"oz/ft^2\", \"mil\", x => x / 1.37f); Converter.AddPath(\"mil\", \"oz/ft^2\", x => x * 1.37f); Converter.AddPath(\"mm\", \"mil\", x => x * 39.37f); Converter.AddPath(\"mil\", \"mm\", x => x / 39.37f); Converter.AddPath(\"mm\", \"mym\", x => x * 1000f); Converter.AddPath(\"mym\", \"mm\", x => x / 1000f); Converter.AddPath(\"F\", \"C\", x => (x - 32) * 5 / 9.0); Converter.AddPath(\"C\", \"F\", x => (x * 1.8 + 32)); string[] StartUnits = new string[] { \"mym\", \"mm\", \"cm\", \"m\", \"in\", \"ft\", \"mil\",\"oz/ft^2\",\"F\",\"C\" }; string[] EndUnits = new string[] { \"mym\", \"mm\", \"cm\", \"m\", \"in\", \"ft\", \"mil\",\"oz/ft^2\",\"F\", \"C\" }; for (int i = 0; i < StartUnits.Length; i++) { double number = Converter.ConvertValue(StartUnits[i], EndUnits[i], 1); Assert.AreEqual(1, number); } } Hier werden dann die Werte der Konvertierungen \u00fcberpr\u00fcft. Wenn ein Ergebnis nicht dem vorgesehenen Wert entspricht, dann schl\u00e4gt der Test fehl. [TestMethod] public void CheckLengthConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"cm\", \"mym\", x => x * 10000); Converter.AddPath(\"cm\", \"mm\", x => x * 10.0); Converter.AddPath(\"cm\", \"m\", x => x / 100.0); Converter.AddPath(\"cm\", \"in\", x => x / 2.54); Converter.AddPath(\"cm\", \"ft\", x => x / 30.48); Converter.AddPath(\"mym\", \"cm\", x => x / 10000); Converter.AddPath(\"m\", \"cm\", x => x * 100.0); Converter.AddPath(\"mm\", \"cm\", x => x / 10.0); Converter.AddPath(\"in\", \"cm\", x => x * 2.54); Converter.AddPath(\"ft\", \"cm\", x => x * 30.48); Converter.AddPath(\"mil\", \"in\", x => x / 1000); Converter.AddPath(\"in\", \"mil\", x => x * 1000); double conversion1 = Converter.ConvertValue(\"mm\", \"mym\", 1); Assert.AreEqual(1000, conversion1); double conversion2 = Converter.ConvertValue(\"mm\", \"cm\", 1); Assert.AreEqual(0.1, conversion2); double conversion3 = Converter.ConvertValue(\"mm\", \"m\", 1); Assert.AreEqual(0.001, conversion3); double conversion4 = Converter.ConvertValue(\"mm\", \"in\", 1); Assert.AreEqual(0.03937007874015748, conversion4); double conversion5 = Converter.ConvertValue(\"mm\", \"ft\", 1); Assert.AreEqual(0.0032808398950131233, conversion5); double conversion6 = Converter.ConvertValue(\"mm\", \"mil\", 1); Assert.AreEqual(39.37007874015748, conversion6); double conversion7 = Converter.ConvertValue(\"cm\", \"mm\", 1); Assert.AreEqual(10, conversion7); double conversion8 = Converter.ConvertValue(\"cm\", \"mym\", 1); Assert.AreEqual(10000, conversion8); double conversion9 = Converter.ConvertValue(\"cm\", \"m\", 1); Assert.AreEqual(0.01, conversion9); double conversion10 = Converter.ConvertValue(\"cm\", \"in\", 1); Assert.AreEqual(0.39370078740157477, conversion10); double conversion11 = Converter.ConvertValue(\"cm\", \"ft\", 1); Assert.AreEqual(0.03280839895013123, conversion11); double conversion12 = Converter.ConvertValue(\"cm\", \"mil\", 1); Assert.AreEqual(393.70078740157476, conversion12); double conversion13 = Converter.ConvertValue(\"m\", \"mm\", 1); Assert.AreEqual(1000, conversion13); double conversion14 = Converter.ConvertValue(\"m\", \"cm\", 1); Assert.AreEqual(100, conversion14); double conversion15 = Converter.ConvertValue(\"m\", \"mym\", 1); Assert.AreEqual(1e+6, conversion15); double conversion16 = Converter.ConvertValue(\"m\", \"in\", 1); Assert.AreEqual(39.37007874015748, conversion16); double conversion17 = Converter.ConvertValue(\"m\", \"ft\", 1); Assert.AreEqual(3.2808398950131235, conversion17); double conversion18 = Converter.ConvertValue(\"m\", \"mil\", 1); Assert.AreEqual(39370.07874015748, conversion18); double conversion19 = Converter.ConvertValue(\"in\", \"mm\", 1); Assert.AreEqual(25.4, conversion19); double conversion20 = Converter.ConvertValue(\"in\", \"cm\", 1); Assert.AreEqual(2.54, conversion20); double conversion21 = Converter.ConvertValue(\"in\", \"m\", 1); Assert.AreEqual(0.0254, conversion21); double conversion22 = Converter.ConvertValue(\"in\", \"mym\", 1); Assert.AreEqual(25400, conversion22); double conversion23 = Converter.ConvertValue(\"in\", \"ft\", 1); Assert.AreEqual(0.08333333333333333, conversion23); double conversion24 = Converter.ConvertValue(\"in\", \"mil\", 1); Assert.AreEqual(1000, conversion24); double conversion25 = Converter.ConvertValue(\"ft\", \"mm\", 1); Assert.AreEqual(304.8, conversion25); double conversion26 = Converter.ConvertValue(\"ft\", \"cm\", 1); Assert.AreEqual(30.48, conversion26); double conversion27 = Converter.ConvertValue(\"ft\", \"m\", 1); Assert.AreEqual(0.3048, conversion27); double conversion28 = Converter.ConvertValue(\"ft\", \"in\", 1); Assert.AreEqual(12, conversion28); double conversion29 = Converter.ConvertValue(\"ft\", \"mym\", 1); Assert.AreEqual(304800, conversion29); double conversion30 = Converter.ConvertValue(\"ft\", \"mil\", 1); Assert.AreEqual(12000, conversion30); double conversion31 = Converter.ConvertValue(\"mil\", \"mm\", 1); Assert.AreEqual(0.025400000000000002, conversion31); double conversion32 = Converter.ConvertValue(\"mil\", \"cm\", 1); Assert.AreEqual(0.00254, conversion32); double conversion33 = Converter.ConvertValue(\"mil\", \"m\", 1); Assert.AreEqual(2.54e-5, conversion33); double conversion34 = Converter.ConvertValue(\"mil\", \"in\", 1); Assert.AreEqual(0.001, conversion34); double conversion35 = Converter.ConvertValue(\"mil\", \"ft\", 1); Assert.AreEqual(8.333333333333333E-05, conversion35); double conversion36 = Converter.ConvertValue(\"mil\", \"mym\", 1); Assert.AreEqual(25.400000000000002, conversion36); } Im Folgenden werden die einzelnen Konvertierungen dann nochmal genauer \u00fcberpr\u00fcft, angefangen bei der Temperatur. [TestMethod] public void CheckTemperatureConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"F\", \"C\", x => (x - 32) * 5 / 9.0); Converter.AddPath(\"C\", \"F\", x => (x * 1.8 + 32)); double conversion1 = Converter.ConvertValue(\"F\", \"C\", 25); Assert.AreEqual(-3.888888888888889, conversion1); double conversion2 = Converter.ConvertValue(\"C\", \"F\", 25); Assert.AreEqual(77, conversion2); } Danach kommt die Konvertierung der Dicke. [TestMethod] public void CheckThicknessConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"oz/ft^2\", \"mil\", x => x / 1.37f); Converter.AddPath(\"mil\", \"oz/ft^2\", x => x * 1.37f); Converter.AddPath(\"mm\", \"mil\", x => x * 39.37f); Converter.AddPath(\"mil\", \"mm\", x => x / 39.37f); Converter.AddPath(\"mm\", \"mym\", x => x * 1000f); Converter.AddPath(\"mym\", \"mm\", x => x / 1000f); double conversion1 = Converter.ConvertValue(\"oz/ft^2\", \"mil\", 1); Assert.AreEqual(0.729927004758713, conversion1); double conversion2 = Converter.ConvertValue(\"oz/ft^2\", \"mm\", 1); Assert.AreEqual(0.01854018350423585, conversion2); double conversion3 = Converter.ConvertValue(\"oz/ft^2\", \"mym\", 1); Assert.AreEqual(18.54018350423585, conversion3); double conversion4 = Converter.ConvertValue(\"mil\", \"oz/ft^2\", 1); Assert.AreEqual(1.3700000047683716, conversion4); double conversion5 = Converter.ConvertValue(\"mil\", \"mm\", 1); Assert.AreEqual(0.0254000514892096, conversion5); double conversion6 = Converter.ConvertValue(\"mil\", \"mym\", 1); Assert.AreEqual(25.4000514892096, conversion6); double conversion7 = Converter.ConvertValue(\"mm\", \"oz/ft^2\", 1); Assert.AreEqual(53.93689872441291, conversion7); double conversion8 = Converter.ConvertValue(\"mm\", \"mym\", 1); Assert.AreEqual(1000, conversion8); double conversion9 = Converter.ConvertValue(\"mm\", \"mil\", 1); Assert.AreEqual(39.369998931884766, conversion9); double conversion10 = Converter.ConvertValue(\"mym\", \"mil\", 1); Assert.AreEqual(0.03936999893188477, conversion10); double conversion11 = Converter.ConvertValue(\"mym\", \"mm\", 1); Assert.AreEqual(0.001, conversion11); double conversion12 = Converter.ConvertValue(\"mym\", \"oz/ft^2\", 1); Assert.AreEqual(0.053936898724412916, conversion12); } Als n\u00e4chstes wird die Calculator Klasse getestet. Dabei werden die Ergebnisse der Methoden mit einem erwarteten Wert verglichen und so \u00fcberpr\u00fcft, ob bei den Rechungen das Richtige rauskommt. [TestMethod] public void CheckLayerCalculation() { Calculator Calculator = new Calculator(); double areaIntern = Calculator.CalculateAreaIntern(1, 10); double areaExtern = Calculator.CalculateAreaExtern(1, 10); Assert.AreEqual(42.39306714892737, areaIntern); Assert.AreEqual(16.296001347209486, areaExtern); double widthInternMil = Calculator.CalculateWidthMil(areaIntern, 1); double widthInternOzFt = Calculator.CalculateWidthOzFt(areaIntern, 1); Assert.AreEqual(42.39306714892737, widthInternMil); Assert.AreEqual(30.764199204258915, widthInternOzFt); double widthExternMil = Calculator.CalculateWidthMil(areaExtern, 1); double widthExternOzFt = Calculator.CalculateWidthOzFt(areaExtern, 1); Assert.AreEqual(16.296001347209486, widthExternMil); Assert.AreEqual(11.825835340416246, widthExternOzFt); } Hier wird getestet, ob die Klasse mit negativen Zahlen rechnen w\u00fcrde, da mit diesen kein korrektes Ergebnis geliefert werden k\u00f6nnte. [TestMethod] public void CheckInputValueCheck() { Calculator Calculator = new Calculator(); Assert.IsTrue(Calculator.CheckInputValue(1, 1, 1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(-1, 1, 1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, -1, 1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, 1, -1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, 1, 1, -1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, 1, 1, 1, -1)); } Als n\u00e4chstes wird geschaut was passiert, wenn man 0 als Wert angibt und ob die Klasse mit diesem Wert auch nicht weiter rechnet. [TestMethod] public void CheckInputUnitCheck() { // Exception WrongInput; Calculator Calculator = new Calculator(); Assert.IsTrue(Calculator.CheckInputUnit(1,1,1,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(0,1,1,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,0,1,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,0,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,0,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,1,0,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,1,1,0)); } In dem n\u00e4chsten Test wird \u00fcberpr\u00fcft, ob der Unit Tree so funktioniert, wie er soll und keine L\u00fccken aufweist. Es wird getestet, was passiert, wenn der Unit Tree keinen Rundlauf hat, wenn es eine schwebene Verbindung gibt und wenn er theoretisch funktionieren sollte. Sind die ersten beiden Test falsch und der letzte richtig, dann funktioniert der Unit Tree wie gedacht. [TestMethod] public void CheckFunctionality() { //kein Rundlauf UnitTree unitTree = new UnitTree(); unitTree.AddPath(\"m\", \"cm\", x => x * 100.0); Assert.IsFalse(unitTree.IsFunctional()); //schwebende Verbindung UnitTree unitTree2 = new UnitTree(); unitTree2.AddPath(\"m\", \"cm\", x => x * 100.0); unitTree2.AddPath(\"cm\", \"m\", x => x / 100); unitTree2.AddPath(\"mm\", \"dm\", x => x / 100); Assert.IsFalse(unitTree2.IsFunctional()); //funktionierender Tree UnitTree unitTree3 = new UnitTree(); unitTree3.AddPath(\"m\", \"cm\", x => x * 100.0); unitTree3.AddPath(\"cm\", \"m\", x => x / 100); unitTree3.AddPath(\"cm\", \"mm\", x => x / 10); unitTree3.AddPath(\"mm\", \"dm\", x => x / 100); unitTree3.AddPath(\"dm\", \"m\", x => x / 10); Assert.IsTrue(unitTree3.IsFunctional()); } In diesem Test werden die Pr\u00e4fixe \u00fcberpr\u00fcft, um zu wissen, ob ihre Werte stimmen. [TestMethod] public void CheckPrefixValue() { SIPrefix[] s = new SIPrefix[] {SIPrefix.Quekto, SIPrefix.Ronto, SIPrefix.Yokto, SIPrefix.Zepto, SIPrefix.Atto , SIPrefix.Femto, SIPrefix.Piko, SIPrefix.Nani, SIPrefix.Mikro, SIPrefix.Milli, SIPrefix.SIDefault, SIPrefix.Kilo, SIPrefix.Mega, SIPrefix.Giga, SIPrefix.Tera, SIPrefix.Peta, SIPrefix.Exa, SIPrefix.Zetta , SIPrefix.Yotta, SIPrefix.Ronna, SIPrefix.Quetta}; int j = -30; foreach(SIPrefix i in s) { Assert.AreEqual(j,((int)i)); j += 3; } SIPrefix[] k = new SIPrefix[] { SIPrefix.Hekto, SIPrefix.Deka, SIPrefix.SIDefault, SIPrefix.Dezi, SIPrefix.Zenti }; int l = 2; foreach(SIPrefix m in k) { Assert.AreEqual(l, (int)m); l -= 1; } } Es wird auch getestet, ob die Konvertierung der Pr\u00e4fixe fehlerfrei funktioniert, damit sich keine Fehler unbemerkt durch das Programm ziehen. [TestMethod] public void CheckConvertSIPrefix() { UnitTree unitTree = new UnitTree(); SIPrefix[] positiv = new SIPrefix[] {SIPrefix.Kilo, SIPrefix.Mega, SIPrefix.Giga, SIPrefix.Tera, SIPrefix.Peta, SIPrefix.Exa, SIPrefix.Zetta , SIPrefix.Yotta, SIPrefix.Ronna, SIPrefix.Quetta}; SIPrefix[] negative = new SIPrefix[] { SIPrefix.Milli, SIPrefix.Mikro, SIPrefix.Nani, SIPrefix.Piko, SIPrefix.Femto, SIPrefix.Atto, SIPrefix.Zepto, SIPrefix.Yokto, SIPrefix.Ronto, SIPrefix.Quekto, }; SIPrefix[] positiveClose = new SIPrefix[] { SIPrefix.SIDefault, SIPrefix.Deka, SIPrefix.Hekto }; SIPrefix[] negativeClose = new SIPrefix[] { SIPrefix.SIDefault, SIPrefix.Dezi, SIPrefix.Zenti }; double k = 1e+3; double l = 1e-3; double n = 1e+0; double m = 1e-0; foreach (SIPrefix i in positiv) { Assert.AreEqual(k, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1)); k *= 1000; } foreach (SIPrefix i in negative) { Assert.AreEqual(l, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1), l * 0.001); l /= 1000; } foreach (SIPrefix i in positiveClose) { Assert.AreEqual(n, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1)); n *= 10; } foreach (SIPrefix i in negativeClose) { Assert.AreEqual(m, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1)); m /= 10; } }","title":"Leiterbahnbreiten"},{"location":"traceWidths/#leiterbahnbreiten","text":"","title":"Leiterbahnbreiten"},{"location":"traceWidths/#einleitung","text":"In diesem Teil wird die Benutzung, der Leiterbahnbreiten Tools erkl\u00e4rt. Um die verschiedenen Einheiten und Gr\u00f6\u00dfen zu verwalten wurde ein Unit Tree benutzt, damit eine gute Performance gew\u00e4hrleistet werden kann. Desweiteren wird die Calculator Klasse benutzt, um die Ergebniseinheiten zu verwalten.","title":"Einleitung"},{"location":"traceWidths/#unittree","text":"Als erstes besitzt der Unit Tree ein Enum, welches alle vorhandenen SI-Pr\u00e4fixe enth\u00e4lt. Diese w\u00e4ren nat\u00fcrlich erweiterbar, falls jemals welche dazu kommen sollten. Zudem besitzt das Enum einen Default, da die Pr\u00e4fixe nicht immer ben\u00f6tigt werden. public enum SIPrefix { Quetta = 30, Ronna = 27, Yotta = 24, Zetta = 21, Exa = 18, Peta = 15, Tera = 12, Giga = 9, Mega = 6, Kilo = 3, Hekto = 2, Deka = 1, SIDefault = 0, Dezi = -1, Zenti = -2, Milli = -3, Mikro = -6, Nani = -9, Piko = -12, Femto = -15, Atto = -18, Zepto = -21, Yokto = -24, Ronto = -27, Quekto = -30 } Danach beginnt auch schon der Unit Tree mit einer Klasse f\u00fcr die Nodes . Die Klasse besitzt zum einem einen String mit der Unit und auch der Parent Unit. Ein Node besteht dabei immer aus einer Unit und dessen Parent Unit. private class Node { public readonly string Unit; public readonly Node? ParentUnit; public Node(string unit, Node? parentUnit) { Unit = unit; ParentUnit = parentUnit; } public override string ToString() { return Unit; } public bool HasUnit(string unit) { return unit == Unit; } } Nach der Node Klasse, folgt die BackTraceNode Klasse. Diese ist vorallem wichtig, um zu \u00fcberpr\u00fcfen, ob der Unit Tree funktioniert. Sie besteht aus einem String, welcher die aktuelle Unit beinhaltet und einer Liste mit den Parent Units. private class BackTraceNode { public readonly string Unit; public List<Node> ParentUnits; public BackTraceNode(string unit) { Unit = unit; } public override string ToString() { return Unit; } public bool HasUnit(string unit) { return unit == Unit; } } Als n\u00e4chstes folgt eine Methode, f\u00fcr die Konvertierung der SI-Pr\u00e4fixe . Sie ben\u00f6tigt die Start und Ziel Unit sowie den Start und Target Pr\u00e4fix. Zudem muss auch ein Wert angegeben werden. Dann werden die Start und Ziel Unit an ConvertValue \u00fcbergeben. Der angegebene Wert wird dann mit 10 StartPr\u00e4fix und 10 ZielPr\u00e4fix multipliziert und auch an ConvertValue \u00fcbergeben. public double ConvertSIPrefixValue(string startUnit, SIPrefix startPrefix, string targetUnit, SIPrefix targetPrefix, double value) { return ConvertValue(startUnit, targetUnit, value * Math.Pow(10.0, (double) startPrefix)) * Math.Pow(10.0, (double) targetPrefix); } Hier ist eine Methode, welche dann den Wert konvertiert . public double ConvertValue(string startUnit, string targetUnit, double value) { IsFunctional(); if (startUnit.Equals(targetUnit)) { return value; } if (_conversion.ContainsKey((startUnit,targetUnit))) { return _conversion[(startUnit, targetUnit)].Invoke(value); } Stack<ConversionFunction> functionStack = CreateConversionStack(startUnit, targetUnit); while (functionStack.Count > 0) { value = functionStack.Pop().Invoke(value); Console.WriteLine(value); } return value; } Zuerst wird gepr\u00fcft, ob der Unit Tree auch funktioniert. Wenn die Start Unit gleich die Ziel Unit ist, dann wird der Wert direkt ausgegeben. Dann wird gepr\u00fcft, ob die Start und Ziel Unit bereits in _conversion vorhanden sind. Danach wird ein functionStack gemacht, mit der Start und Ziel Unit. Solange dieser Stack gr\u00f6\u00dfer als 0 ist, wird das oberste Element vom Stack ausgegeben. Hier wird viel mit dem Unit Tree gearbeitet, um von der Start Unit zur Ziel Unit zu gelangen. Stack<ConversionFunction> CreateConversionStack(string startUnit, string targetUnit) { Queue<Node> openQueue = new Queue<Node>(); List<Node> closedList = new List<Node>(); HashSet<string> processedUnits = new HashSet<string>(); openQueue.Enqueue(new Node(startUnit, null)); processedUnits.Add(startUnit); while (!_conversion.ContainsKey((openQueue.Peek().Unit, targetUnit))) { Node currentItem = openQueue.Dequeue(); closedList.Add(currentItem); foreach (var y in _conversion.Keys.Where(x => x.from == currentItem.ToString())) { if (!processedUnits.Contains(y.to)) { openQueue.Enqueue(new Node(y.to, currentItem)); processedUnits.Add(y.to); } } } closedList.Add(openQueue.Peek()); Stack<ConversionFunction> functionStack = new Stack<ConversionFunction>(); Node currentNode = new Node(targetUnit, openQueue.Peek()); while (currentNode.ParentUnit != null) { Console.WriteLine(currentNode.Unit); functionStack.Push(_conversion[(currentNode.ParentUnit.Unit, currentNode.Unit)]); currentNode = currentNode.ParentUnit; } return functionStack; } Zuerst wird eine Queue f\u00fcr die Openlist und eine List f\u00fcr die Closedlist angelegt. Noch dazu kommt ein HashSet f\u00fcr die bearbeiteten Units (ProcessedUnits). Angefangen wird damit, dass der Openlist die Start Unit hinzugef\u00fcgt wird. Die Parent Unit ist dabei nat\u00fcrlich Null, da die Start Unit in der Regel kein Parent hat. An ProcessedUnits wird die Start Unit auch \u00fcbergeben. Solange _conversion nicht die oberste Unit der Openlist und die Ziel Unit beinhaltet, bekommt currentItem die oberste Unit aus der Openlist , welches gleichzeitig aus der Liste entfernt wird. Die Unit von currentItem kommt dann in die Closedlist . F\u00fcr jedes Element in _conversion wo, x.from das currentItem ist, wird gepr\u00fcft, ob die processedUnits y.to nicht beinhalten. Falls dies der Fall sein sollte, wird der Openlist y.to und currentItem hinzugef\u00fcgt. ProcessedUnits wird auch y.to hizugef\u00fcgt. Danach wird der Closedlist die oberste Unit der Openlist hinzugef\u00fcgt und es wird der functionStack erstellt. Zudem kommt eine neue Node, die currentNode, welche die Ziel Unit und das oberste Element der Openlist beinhaltet. Solange die Parent Unit der currentNode nicht Null ist, wird die currentNode Unit ausgegeben. Der functionStack bekommt oben drauf noch _conversion mit der Parent Unit von currentNode und die Unit von currentNode. Danach bekommt die neue currentNode die Unit von der vorherigen Parent Unit zugewiesen. Zum Schluss wird noch der functionStack zur\u00fcckgegeben. Bei AddPath werden Pfade dem Unit Tree hinzugef\u00fcgt. Solange dies passiert, fuktioniert der Unit Tree nicht, weshalb _functional auch false ist. Hierbei wird _conversion die Start und Ziel Unit und conversionFunc \u00fcbergeben. public void AddPath(string startUnit, string targetUnit, ConversionFunction conversionFunc) { _functional = false; _conversion.TryAdd((startUnit,targetUnit), conversionFunc); } Zum Schluss wird noch \u00fcberpr\u00fcft, ob der Unit Tree funktioniert , damit m\u00f6gliche Fehler fr\u00fchzeitig erkannt werden. private void checkFunctionality() { Dictionary<string,List<string>?> traceBook= new Dictionary<string,List<string>>(); Queue<string> openNodes = new Queue<string>(); traceBook.Add(_conversion.First().Key.from,null); openNodes.Enqueue(_conversion.First().Key.from); do { foreach (var y in _conversion.Keys.Where(x => x.from == openNodes.Peek())) { if (!traceBook.ContainsKey(y.to)) { traceBook.Add(y.to,new List<string>(){y.from}); openNodes.Enqueue(y.to); } else if (traceBook[y.to] != null) { traceBook[y.to].Add(y.from); } else if (traceBook[y.from] != null) { Queue<string> backTrace = new Queue<string>(); foreach (string parent in traceBook[y.from]) { if (traceBook[parent] != null) backTrace.Enqueue(parent); } traceBook[y.from] = null; while (backTrace.Count > 0) { foreach (string parent in traceBook[backTrace.Peek()]) { if (traceBook[parent] != null) backTrace.Enqueue(parent); } traceBook[backTrace.Dequeue()] = null; } } } openNodes.Dequeue(); } while (openNodes.Count > 0); if (traceBook.Count(x => x.Value != null) > 0 || traceBook.Count < _conversion.DistinctBy(y => y.Key.from).Count()) { _functional = false; } else { _functional = true; } } Dabei wird zuerst das Dictionary tracebook und eine Queue mit den noch unbearbeiteten Nodes (openNodes) angelegt. Zum tracebook wird zuerst das erste Element 'from' von _conversion und Null hinzugef\u00fcgt. Bei OpenNodes wird dieses erste Element auch hinzugef\u00fcgt. Danach wird, solange etwas in openNodes vorhanden ist, f\u00fcr jedes Element in _conversion wo x.from gleich das oberste Element von openNodes gepr\u00fcft, ob tracebook y.to nicht beinhaltet. Wenn das der Fall sein sollte, dann wird y.to und eine Liste mit y.from dem tracebook hinzugef\u00fcgt. Ansonsten, wenn y.to vom tracebook nicht gleich Null ist, wird zu y.to vom tracebook y.from hinzugef\u00fcgt. Und wenn y.from vom tracebook nicht gleich Null ist, dann wird eine neue Queue mit dem Namen backtrace angelegt. F\u00fcr jeden parent in backtrace wird \u00fcberpr\u00fcft, ob dieser Null ist. Wenn dies nicht der Fall sein sollte, dann wird dieser parent dem tracebook hinzugef\u00fcgt. Danach wird y.from vom tracebook wieder auf Null gesetzt. Solange in backtrace noch Elemente vorhanden sind, wird vom obersten Element in backtrace gepr\u00fcft ob der parent vom tracebook gleich Null ist. Sollte dies nicht der Fall sein, dann wird der parent dem backtrace hinzugef\u00fcgt. Danach werden das backtrace und die openNodes noch geleert. Zum Schluss wird noch gepr\u00fcft, ob die Anzahl an Values aus dem tracebook, welche nicht gleich Null sind gr\u00f6\u00dfer als 0 sind oder ob das tracebook weniger Elemente als _conversion y.from Elemente hat. Wenn eine der beiden Bedingungen stimmen sollte, dann wird der Unit Tree nicht funktionieren. Wenn das bool _functional false sein sollte, dann wird der Unit Tree gepr\u00fcft, um zu schauen, ob es wirklich false ist. Wenn das bool dann immer noch false sein sollte, dann wird einem in der Konsole deutlich gezeigt, dass etwas nicht ganz funktioniert. public bool IsFunctional() { if (!_functional) { checkFunctionality(); } if (!_functional) { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine(\"!!!Using not functional UnitTree!!!\"); Console.ResetColor(); } return _functional; }","title":"UnitTree"},{"location":"traceWidths/#calculator","text":"Au\u00dferdem gibt es eine Klasse, die die einzelnen Einheiten der Ergebnisse vom Kalkulator verwaltet. Dazu geh\u00f6ren sowohl die ben\u00f6tigte Fl\u00e4che der inneren Schicht als auch der \u00e4u\u00dferen Schicht. public double CalculateAreaIntern(double ampere, double tRise) { double I = ampere; double TRise = tRise; const double constantK = 0.024; double constantB = 0.44; double constantC = 0.725; double area; area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC)); return area; } public double CalculateAreaExtern(double ampere, double tRise) { double I = ampere; double TRise = tRise; double constantK = 0.048; double constantB = 0.44; double constantC = 0.725; double area; area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC)); return area; } Und nat\u00fcrlich auch f\u00fcr die Breite der Leiterbahnen . Einmal wird dabei mit Mil gerechnet und einmal mit Oz/Ft 2 . public double CalculateWidthMil(double area, double thickness) { double A = area; double t = thickness; double width; width = A / t; return width; } public double CalculateWidthOzFt(double area, double thickness) { return CalculateWidthMil(area, thickness * 1.378f); } Hier wird dann direkt \u00fcberpr\u00fcft, ob der eingegebene Wert verwendet werden kann oder ob dieser nicht erlaubt ist. public bool CheckInputValue(double ampereValue, double temperatureValue, double ThicknessValue, double traceLengthValue, double temperaturRiseValue) { double[] InputValue = { ampereValue, temperatureValue, ThicknessValue, traceLengthValue, temperaturRiseValue }; if(InputValue.Any(x => x <= 0)) { return false; } return true; } Als n\u00e4chstes wird auch \u00fcberpr\u00fcft, ob die eingegebene Unit zul\u00e4ssig ist. Falls dies nicht der Fall sein sollte, dann gibt das Bool false aus. public bool CheckInputUnit(double targetUnitTemperature, double targetUnitThickness, double targetUnitTraceLength, double targetUnitTemperaturRise, double targetUnitWidthIntern, double targetUnitWidthExtern) { int tempResult = 0; int tempRiseResult = 0; int thickResult = 0; int traceLenghtResult = 0; int widthInternResult = 0; int widthExternResult = 0; if (targetUnitTemperature > 0 && targetUnitThickness < 2 && targetUnitTemperaturRise > 0 && targetUnitTemperaturRise < 2) { tempResult = 1; tempRiseResult = 1; } if (targetUnitThickness > 0 && targetUnitThickness < 4) { thickResult = 1; } if(targetUnitTraceLength > 0 && targetUnitTraceLength < 7) { traceLenghtResult = 1; } if(targetUnitWidthIntern > 0 && targetUnitWidthIntern < 3 && targetUnitWidthExtern > 0 && targetUnitWidthExtern < 3) { widthInternResult = 1; widthExternResult = 1; } double[] UnitCheck = { tempResult, tempRiseResult, thickResult, traceLenghtResult, widthInternResult, widthExternResult }; if (UnitCheck.Any(x => x < 1)) { return false; } return true; }","title":"Calculator"},{"location":"traceWidths/#testing","text":"Um sicher zu stellen, dass alles funktioniert, haben wir mit Unit Tests verschiedene Methoden und Klassen getestet. Zum einen wurden der Kalkulator sowie die Pr\u00e4fixe getestet und es wurden Tests mit verschiedenen Zahlen gemacht. Zudem wird zus\u00e4tzlich \u00fcberpr\u00fcft, ob der Unit Tree funktioniert, da dieser eins der wichtigsten Elemente der Klasse ist. Calculator Test Um den Unit Tree zu testen gibt es viele Funktionen, um sicher zu stellen, dass keine Fehler auftauchen k\u00f6nnen. Zuerst wird \u00fcberpr\u00fcft, ob die Konvertierung der Einheiten funktioniert. Dabei werden alle Einheiten benutzt, um alle M\u00f6glichkeiten zu \u00fcberpr\u00fcfen. [TestMethod] public void CheckSelfConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"cm\", \"mym\", x => x * 10000); Converter.AddPath(\"cm\", \"mm\", x => x * 10.0); Converter.AddPath(\"cm\", \"m\", x => x / 100.0); Converter.AddPath(\"cm\", \"in\", x => x / 2.54); Converter.AddPath(\"cm\", \"ft\", x => x / 30.48); Converter.AddPath(\"mym\", \"cm\", x => x / 10000); Converter.AddPath(\"m\", \"cm\", x => x * 100.0); Converter.AddPath(\"mm\", \"cm\", x => x / 10.0); Converter.AddPath(\"in\", \"cm\", x => x * 2.54); Converter.AddPath(\"ft\", \"cm\", x => x * 30.48); Converter.AddPath(\"mil\", \"in\", x => x / 1000); Converter.AddPath(\"in\", \"mil\", x => x * 1000); Converter.AddPath(\"oz/ft^2\", \"mil\", x => x / 1.37f); Converter.AddPath(\"mil\", \"oz/ft^2\", x => x * 1.37f); Converter.AddPath(\"mm\", \"mil\", x => x * 39.37f); Converter.AddPath(\"mil\", \"mm\", x => x / 39.37f); Converter.AddPath(\"mm\", \"mym\", x => x * 1000f); Converter.AddPath(\"mym\", \"mm\", x => x / 1000f); Converter.AddPath(\"F\", \"C\", x => (x - 32) * 5 / 9.0); Converter.AddPath(\"C\", \"F\", x => (x * 1.8 + 32)); string[] StartUnits = new string[] { \"mym\", \"mm\", \"cm\", \"m\", \"in\", \"ft\", \"mil\",\"oz/ft^2\",\"F\",\"C\" }; string[] EndUnits = new string[] { \"mym\", \"mm\", \"cm\", \"m\", \"in\", \"ft\", \"mil\",\"oz/ft^2\",\"F\", \"C\" }; for (int i = 0; i < StartUnits.Length; i++) { double number = Converter.ConvertValue(StartUnits[i], EndUnits[i], 1); Assert.AreEqual(1, number); } } Hier werden dann die Werte der Konvertierungen \u00fcberpr\u00fcft. Wenn ein Ergebnis nicht dem vorgesehenen Wert entspricht, dann schl\u00e4gt der Test fehl. [TestMethod] public void CheckLengthConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"cm\", \"mym\", x => x * 10000); Converter.AddPath(\"cm\", \"mm\", x => x * 10.0); Converter.AddPath(\"cm\", \"m\", x => x / 100.0); Converter.AddPath(\"cm\", \"in\", x => x / 2.54); Converter.AddPath(\"cm\", \"ft\", x => x / 30.48); Converter.AddPath(\"mym\", \"cm\", x => x / 10000); Converter.AddPath(\"m\", \"cm\", x => x * 100.0); Converter.AddPath(\"mm\", \"cm\", x => x / 10.0); Converter.AddPath(\"in\", \"cm\", x => x * 2.54); Converter.AddPath(\"ft\", \"cm\", x => x * 30.48); Converter.AddPath(\"mil\", \"in\", x => x / 1000); Converter.AddPath(\"in\", \"mil\", x => x * 1000); double conversion1 = Converter.ConvertValue(\"mm\", \"mym\", 1); Assert.AreEqual(1000, conversion1); double conversion2 = Converter.ConvertValue(\"mm\", \"cm\", 1); Assert.AreEqual(0.1, conversion2); double conversion3 = Converter.ConvertValue(\"mm\", \"m\", 1); Assert.AreEqual(0.001, conversion3); double conversion4 = Converter.ConvertValue(\"mm\", \"in\", 1); Assert.AreEqual(0.03937007874015748, conversion4); double conversion5 = Converter.ConvertValue(\"mm\", \"ft\", 1); Assert.AreEqual(0.0032808398950131233, conversion5); double conversion6 = Converter.ConvertValue(\"mm\", \"mil\", 1); Assert.AreEqual(39.37007874015748, conversion6); double conversion7 = Converter.ConvertValue(\"cm\", \"mm\", 1); Assert.AreEqual(10, conversion7); double conversion8 = Converter.ConvertValue(\"cm\", \"mym\", 1); Assert.AreEqual(10000, conversion8); double conversion9 = Converter.ConvertValue(\"cm\", \"m\", 1); Assert.AreEqual(0.01, conversion9); double conversion10 = Converter.ConvertValue(\"cm\", \"in\", 1); Assert.AreEqual(0.39370078740157477, conversion10); double conversion11 = Converter.ConvertValue(\"cm\", \"ft\", 1); Assert.AreEqual(0.03280839895013123, conversion11); double conversion12 = Converter.ConvertValue(\"cm\", \"mil\", 1); Assert.AreEqual(393.70078740157476, conversion12); double conversion13 = Converter.ConvertValue(\"m\", \"mm\", 1); Assert.AreEqual(1000, conversion13); double conversion14 = Converter.ConvertValue(\"m\", \"cm\", 1); Assert.AreEqual(100, conversion14); double conversion15 = Converter.ConvertValue(\"m\", \"mym\", 1); Assert.AreEqual(1e+6, conversion15); double conversion16 = Converter.ConvertValue(\"m\", \"in\", 1); Assert.AreEqual(39.37007874015748, conversion16); double conversion17 = Converter.ConvertValue(\"m\", \"ft\", 1); Assert.AreEqual(3.2808398950131235, conversion17); double conversion18 = Converter.ConvertValue(\"m\", \"mil\", 1); Assert.AreEqual(39370.07874015748, conversion18); double conversion19 = Converter.ConvertValue(\"in\", \"mm\", 1); Assert.AreEqual(25.4, conversion19); double conversion20 = Converter.ConvertValue(\"in\", \"cm\", 1); Assert.AreEqual(2.54, conversion20); double conversion21 = Converter.ConvertValue(\"in\", \"m\", 1); Assert.AreEqual(0.0254, conversion21); double conversion22 = Converter.ConvertValue(\"in\", \"mym\", 1); Assert.AreEqual(25400, conversion22); double conversion23 = Converter.ConvertValue(\"in\", \"ft\", 1); Assert.AreEqual(0.08333333333333333, conversion23); double conversion24 = Converter.ConvertValue(\"in\", \"mil\", 1); Assert.AreEqual(1000, conversion24); double conversion25 = Converter.ConvertValue(\"ft\", \"mm\", 1); Assert.AreEqual(304.8, conversion25); double conversion26 = Converter.ConvertValue(\"ft\", \"cm\", 1); Assert.AreEqual(30.48, conversion26); double conversion27 = Converter.ConvertValue(\"ft\", \"m\", 1); Assert.AreEqual(0.3048, conversion27); double conversion28 = Converter.ConvertValue(\"ft\", \"in\", 1); Assert.AreEqual(12, conversion28); double conversion29 = Converter.ConvertValue(\"ft\", \"mym\", 1); Assert.AreEqual(304800, conversion29); double conversion30 = Converter.ConvertValue(\"ft\", \"mil\", 1); Assert.AreEqual(12000, conversion30); double conversion31 = Converter.ConvertValue(\"mil\", \"mm\", 1); Assert.AreEqual(0.025400000000000002, conversion31); double conversion32 = Converter.ConvertValue(\"mil\", \"cm\", 1); Assert.AreEqual(0.00254, conversion32); double conversion33 = Converter.ConvertValue(\"mil\", \"m\", 1); Assert.AreEqual(2.54e-5, conversion33); double conversion34 = Converter.ConvertValue(\"mil\", \"in\", 1); Assert.AreEqual(0.001, conversion34); double conversion35 = Converter.ConvertValue(\"mil\", \"ft\", 1); Assert.AreEqual(8.333333333333333E-05, conversion35); double conversion36 = Converter.ConvertValue(\"mil\", \"mym\", 1); Assert.AreEqual(25.400000000000002, conversion36); } Im Folgenden werden die einzelnen Konvertierungen dann nochmal genauer \u00fcberpr\u00fcft, angefangen bei der Temperatur. [TestMethod] public void CheckTemperatureConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"F\", \"C\", x => (x - 32) * 5 / 9.0); Converter.AddPath(\"C\", \"F\", x => (x * 1.8 + 32)); double conversion1 = Converter.ConvertValue(\"F\", \"C\", 25); Assert.AreEqual(-3.888888888888889, conversion1); double conversion2 = Converter.ConvertValue(\"C\", \"F\", 25); Assert.AreEqual(77, conversion2); } Danach kommt die Konvertierung der Dicke. [TestMethod] public void CheckThicknessConversion() { UnitTree Converter = new UnitTree(); Converter.AddPath(\"oz/ft^2\", \"mil\", x => x / 1.37f); Converter.AddPath(\"mil\", \"oz/ft^2\", x => x * 1.37f); Converter.AddPath(\"mm\", \"mil\", x => x * 39.37f); Converter.AddPath(\"mil\", \"mm\", x => x / 39.37f); Converter.AddPath(\"mm\", \"mym\", x => x * 1000f); Converter.AddPath(\"mym\", \"mm\", x => x / 1000f); double conversion1 = Converter.ConvertValue(\"oz/ft^2\", \"mil\", 1); Assert.AreEqual(0.729927004758713, conversion1); double conversion2 = Converter.ConvertValue(\"oz/ft^2\", \"mm\", 1); Assert.AreEqual(0.01854018350423585, conversion2); double conversion3 = Converter.ConvertValue(\"oz/ft^2\", \"mym\", 1); Assert.AreEqual(18.54018350423585, conversion3); double conversion4 = Converter.ConvertValue(\"mil\", \"oz/ft^2\", 1); Assert.AreEqual(1.3700000047683716, conversion4); double conversion5 = Converter.ConvertValue(\"mil\", \"mm\", 1); Assert.AreEqual(0.0254000514892096, conversion5); double conversion6 = Converter.ConvertValue(\"mil\", \"mym\", 1); Assert.AreEqual(25.4000514892096, conversion6); double conversion7 = Converter.ConvertValue(\"mm\", \"oz/ft^2\", 1); Assert.AreEqual(53.93689872441291, conversion7); double conversion8 = Converter.ConvertValue(\"mm\", \"mym\", 1); Assert.AreEqual(1000, conversion8); double conversion9 = Converter.ConvertValue(\"mm\", \"mil\", 1); Assert.AreEqual(39.369998931884766, conversion9); double conversion10 = Converter.ConvertValue(\"mym\", \"mil\", 1); Assert.AreEqual(0.03936999893188477, conversion10); double conversion11 = Converter.ConvertValue(\"mym\", \"mm\", 1); Assert.AreEqual(0.001, conversion11); double conversion12 = Converter.ConvertValue(\"mym\", \"oz/ft^2\", 1); Assert.AreEqual(0.053936898724412916, conversion12); } Als n\u00e4chstes wird die Calculator Klasse getestet. Dabei werden die Ergebnisse der Methoden mit einem erwarteten Wert verglichen und so \u00fcberpr\u00fcft, ob bei den Rechungen das Richtige rauskommt. [TestMethod] public void CheckLayerCalculation() { Calculator Calculator = new Calculator(); double areaIntern = Calculator.CalculateAreaIntern(1, 10); double areaExtern = Calculator.CalculateAreaExtern(1, 10); Assert.AreEqual(42.39306714892737, areaIntern); Assert.AreEqual(16.296001347209486, areaExtern); double widthInternMil = Calculator.CalculateWidthMil(areaIntern, 1); double widthInternOzFt = Calculator.CalculateWidthOzFt(areaIntern, 1); Assert.AreEqual(42.39306714892737, widthInternMil); Assert.AreEqual(30.764199204258915, widthInternOzFt); double widthExternMil = Calculator.CalculateWidthMil(areaExtern, 1); double widthExternOzFt = Calculator.CalculateWidthOzFt(areaExtern, 1); Assert.AreEqual(16.296001347209486, widthExternMil); Assert.AreEqual(11.825835340416246, widthExternOzFt); } Hier wird getestet, ob die Klasse mit negativen Zahlen rechnen w\u00fcrde, da mit diesen kein korrektes Ergebnis geliefert werden k\u00f6nnte. [TestMethod] public void CheckInputValueCheck() { Calculator Calculator = new Calculator(); Assert.IsTrue(Calculator.CheckInputValue(1, 1, 1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(-1, 1, 1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, -1, 1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, 1, -1, 1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, 1, 1, -1, 1)); Assert.IsFalse(Calculator.CheckInputValue(1, 1, 1, 1, -1)); } Als n\u00e4chstes wird geschaut was passiert, wenn man 0 als Wert angibt und ob die Klasse mit diesem Wert auch nicht weiter rechnet. [TestMethod] public void CheckInputUnitCheck() { // Exception WrongInput; Calculator Calculator = new Calculator(); Assert.IsTrue(Calculator.CheckInputUnit(1,1,1,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(0,1,1,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,0,1,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,0,1,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,0,1,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,1,0,1)); Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,1,1,0)); } In dem n\u00e4chsten Test wird \u00fcberpr\u00fcft, ob der Unit Tree so funktioniert, wie er soll und keine L\u00fccken aufweist. Es wird getestet, was passiert, wenn der Unit Tree keinen Rundlauf hat, wenn es eine schwebene Verbindung gibt und wenn er theoretisch funktionieren sollte. Sind die ersten beiden Test falsch und der letzte richtig, dann funktioniert der Unit Tree wie gedacht. [TestMethod] public void CheckFunctionality() { //kein Rundlauf UnitTree unitTree = new UnitTree(); unitTree.AddPath(\"m\", \"cm\", x => x * 100.0); Assert.IsFalse(unitTree.IsFunctional()); //schwebende Verbindung UnitTree unitTree2 = new UnitTree(); unitTree2.AddPath(\"m\", \"cm\", x => x * 100.0); unitTree2.AddPath(\"cm\", \"m\", x => x / 100); unitTree2.AddPath(\"mm\", \"dm\", x => x / 100); Assert.IsFalse(unitTree2.IsFunctional()); //funktionierender Tree UnitTree unitTree3 = new UnitTree(); unitTree3.AddPath(\"m\", \"cm\", x => x * 100.0); unitTree3.AddPath(\"cm\", \"m\", x => x / 100); unitTree3.AddPath(\"cm\", \"mm\", x => x / 10); unitTree3.AddPath(\"mm\", \"dm\", x => x / 100); unitTree3.AddPath(\"dm\", \"m\", x => x / 10); Assert.IsTrue(unitTree3.IsFunctional()); } In diesem Test werden die Pr\u00e4fixe \u00fcberpr\u00fcft, um zu wissen, ob ihre Werte stimmen. [TestMethod] public void CheckPrefixValue() { SIPrefix[] s = new SIPrefix[] {SIPrefix.Quekto, SIPrefix.Ronto, SIPrefix.Yokto, SIPrefix.Zepto, SIPrefix.Atto , SIPrefix.Femto, SIPrefix.Piko, SIPrefix.Nani, SIPrefix.Mikro, SIPrefix.Milli, SIPrefix.SIDefault, SIPrefix.Kilo, SIPrefix.Mega, SIPrefix.Giga, SIPrefix.Tera, SIPrefix.Peta, SIPrefix.Exa, SIPrefix.Zetta , SIPrefix.Yotta, SIPrefix.Ronna, SIPrefix.Quetta}; int j = -30; foreach(SIPrefix i in s) { Assert.AreEqual(j,((int)i)); j += 3; } SIPrefix[] k = new SIPrefix[] { SIPrefix.Hekto, SIPrefix.Deka, SIPrefix.SIDefault, SIPrefix.Dezi, SIPrefix.Zenti }; int l = 2; foreach(SIPrefix m in k) { Assert.AreEqual(l, (int)m); l -= 1; } } Es wird auch getestet, ob die Konvertierung der Pr\u00e4fixe fehlerfrei funktioniert, damit sich keine Fehler unbemerkt durch das Programm ziehen. [TestMethod] public void CheckConvertSIPrefix() { UnitTree unitTree = new UnitTree(); SIPrefix[] positiv = new SIPrefix[] {SIPrefix.Kilo, SIPrefix.Mega, SIPrefix.Giga, SIPrefix.Tera, SIPrefix.Peta, SIPrefix.Exa, SIPrefix.Zetta , SIPrefix.Yotta, SIPrefix.Ronna, SIPrefix.Quetta}; SIPrefix[] negative = new SIPrefix[] { SIPrefix.Milli, SIPrefix.Mikro, SIPrefix.Nani, SIPrefix.Piko, SIPrefix.Femto, SIPrefix.Atto, SIPrefix.Zepto, SIPrefix.Yokto, SIPrefix.Ronto, SIPrefix.Quekto, }; SIPrefix[] positiveClose = new SIPrefix[] { SIPrefix.SIDefault, SIPrefix.Deka, SIPrefix.Hekto }; SIPrefix[] negativeClose = new SIPrefix[] { SIPrefix.SIDefault, SIPrefix.Dezi, SIPrefix.Zenti }; double k = 1e+3; double l = 1e-3; double n = 1e+0; double m = 1e-0; foreach (SIPrefix i in positiv) { Assert.AreEqual(k, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1)); k *= 1000; } foreach (SIPrefix i in negative) { Assert.AreEqual(l, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1), l * 0.001); l /= 1000; } foreach (SIPrefix i in positiveClose) { Assert.AreEqual(n, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1)); n *= 10; } foreach (SIPrefix i in negativeClose) { Assert.AreEqual(m, unitTree.ConvertSIPrefixValue(\"m\", SIPrefix.SIDefault, \"m\", i, 1)); m /= 10; } }","title":"Testing"}]}