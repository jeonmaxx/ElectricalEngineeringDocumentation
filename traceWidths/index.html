<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://jeonmaxx.github.io/ElectricalEngineeringDocumentation/traceWidths/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Leiterbahnbreiten - Electrical Engineering Toolbox</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Electrical Engineering Toolbox</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../resistance/" class="nav-link">Widerstand</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Leiterbahnbreiten</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../resistance/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#leiterbahnbreiten" class="nav-link">Leiterbahnbreiten</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#einleitung" class="nav-link">Einleitung</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#unittree" class="nav-link">UnitTree</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#calculator" class="nav-link">Calculator</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#testing" class="nav-link">Testing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="leiterbahnbreiten">Leiterbahnbreiten</h1>
<h2 id="einleitung">Einleitung</h2>
<p>In diesem Teil wird die Benutzung, der <mark>Leiterbahnbreiten Tools</mark> erkl&auml;rt. 
Um die verschiedenen Einheiten und Gr&ouml;&szlig;en zu verwalten wurde ein <strong>Unit Tree</strong> benutzt, damit eine gute Performance zu gew&auml;hrleistet wird. 
Desweiteren wird die <strong>Calculator</strong> Klasse benutzt, um die Ergebniss Einheiten zu verwalten.</p>
<h2 id="unittree">UnitTree</h2>
<p>Als erstes besitzt der Unit Tree ein Enum, welches alle vorhandenen <strong>SI-Pr&auml;fixe</strong> enth&auml;lt. 
Diese w&auml;ren nat&uuml;rlich erweiterbar, falls jemals welche dazu kommen sollten.
Zudem besitzt das Enum einen Default, da die Pr&auml;fixe nicht immer ben&ouml;tigt werden.</p>
<pre><code class="language-c#">        public enum SIPrefix
        {
            Quetta = 30,
            Ronna = 27,
            Yotta = 24,
            Zetta = 21,
            Exa = 18,
            Peta = 15,
            Tera = 12,
            Giga = 9,
            Mega = 6,
            Kilo = 3,
            Hekto = 2,
            Deka = 1,
            SIDefault = 0,
            Dezi = -1,
            Zenti = -2,
            Milli = -3,
            Mikro = -6,
            Nani = -9,
            Piko = -12,
            Femto = -15,
            Atto = -18,
            Zepto = -21,
            Yokto = -24,
            Ronto = -27,
            Quekto = -30
        }
</code></pre>
<p>Danach beginnt auch schon der Unit Tree mit einer Klassen f&uuml;r die <strong>Nodes</strong>. 
Die Klasse besitzt zum einem einen String mit der Unit und auch der Parent Unit. 
Ein Node besteht dabei immer aus einer Unit und dessen Parent Unit.</p>
<pre><code class="language-c#">        private class Node
        {
            public readonly string Unit;
            public readonly Node? ParentUnit;

            public Node(string unit, Node? parentUnit)
            {
                Unit = unit;
                ParentUnit = parentUnit;
            }

            public override string ToString()
            {
                return Unit;
            }

            public bool HasUnit(string unit)
            {
                return unit == Unit;
            }
        }
</code></pre>
<p>Nach der Node Klasse, folgt die <strong>BackTraceNode</strong> Klasse. 
Diese ist vorallem wichtig, um zu &uuml;berpr&uuml;fen, ob der Unit Tree funktioniert. 
Sie besteht aus einem string, welcher die aktuelle Unit beihaltet und einer Liste mit dem Parent Units.</p>
<pre><code class="language-c#">        private class BackTraceNode
        {
            public readonly string Unit;
            public List&lt;Node&gt; ParentUnits;

            public BackTraceNode(string unit)
            {
                Unit = unit;
            }

            public override string ToString()
            {
                return Unit;
            }

            public bool HasUnit(string unit)
            {
                return unit == Unit;
            }
        }
</code></pre>
<p>Als n&auml;chstes folgt eine Methode, f&uuml;r die <strong>Konvertierung der SI-Pr&auml;fixe</strong>. 
Sie ben&ouml;tigt die Start und Ziel Unit, sowie den Start und Target Pr&auml;fix. 
Zudem muss auch ein Wert angegeben werden. 
Dann werden die Start und Ziel Unit an ConvertValue &uuml;bergeben. 
Der angegebene Wert wird dann mit 10<sup>StartPr&auml;fix</sup> mal 10<sup>ZielPr&auml;fix</sup> mal genommen und auch an ConvertValue &uuml;bergeben.</p>
<pre><code class="language-c#">        public double ConvertSIPrefixValue(string startUnit, SIPrefix startPrefix, string targetUnit,
            SIPrefix targetPrefix, double value)
        {
            return ConvertValue(startUnit, targetUnit, value * Math.Pow(10.0, (double) startPrefix)) *
                   Math.Pow(10.0, (double) targetPrefix);
        }
</code></pre>
<p>Hier ist eine Methode, welche dann den <strong>Wert konvertiert</strong>. </p>
<pre><code class="language-c#">        public double ConvertValue(string startUnit, string targetUnit, double value)
        {
            IsFunctional();

            if (startUnit.Equals(targetUnit))
            {
                return value;
            }

            if (_conversion.ContainsKey((startUnit,targetUnit)))
            {
                return _conversion[(startUnit, targetUnit)].Invoke(value);
            }

            Stack&lt;ConversionFunction&gt; functionStack = CreateConversionStack(startUnit, targetUnit);

            while (functionStack.Count &gt; 0)
            {
                value = functionStack.Pop().Invoke(value);
                Console.WriteLine(value);
            }

            return value;
        }
</code></pre>
<p>Zuerst wird gepr&uuml;ft, ob der Unit Tree auch funktioniert. 
Wenn die Start Unit gleich die Ziel Unit ist, dann wird der Wert direkt ausgegeben. 
Dann wird gepr&uuml;ft, ob die Start und Ziel Unit bereits in _conversion vorhanden sind. 
Danach wird ein functionStack gemacht, mit der Start und Ziel Unit. 
Solange dieser Stack gr&ouml;&szlig;er als 0 ist, wird das oberste Element vom Stack ausgegeben.  </p>
<p>Hier wird viel mit dem Unit Tree gearbeitet, um von der <mark>Start Unit zur Ziel Unit</mark> zu gelangen.</p>
<pre><code class="language-c#">        Stack&lt;ConversionFunction&gt; CreateConversionStack(string startUnit, string targetUnit)
        {
            Queue&lt;Node&gt; openQueue = new Queue&lt;Node&gt;();
            List&lt;Node&gt; closedList = new List&lt;Node&gt;();
            HashSet&lt;string&gt; processedUnits = new HashSet&lt;string&gt;();

            openQueue.Enqueue(new Node(startUnit, null));
            processedUnits.Add(startUnit);

            while (!_conversion.ContainsKey((openQueue.Peek().Unit, targetUnit)))
            {
                Node currentItem = openQueue.Dequeue();
                closedList.Add(currentItem);
                foreach (var y in _conversion.Keys.Where(x =&gt; x.from == currentItem.ToString()))
                {
                    if (!processedUnits.Contains(y.to))
                    {
                        openQueue.Enqueue(new Node(y.to, currentItem));
                        processedUnits.Add(y.to);
                    }
                }
            }

            closedList.Add(openQueue.Peek());
            Stack&lt;ConversionFunction&gt; functionStack = new Stack&lt;ConversionFunction&gt;();
            Node currentNode = new Node(targetUnit, openQueue.Peek());

            while (currentNode.ParentUnit != null)
            {
                Console.WriteLine(currentNode.Unit);
                functionStack.Push(_conversion[(currentNode.ParentUnit.Unit, currentNode.Unit)]);
                currentNode = currentNode.ParentUnit;
            }

            return functionStack;
        }
</code></pre>
<p>Zuerst wird eine Queue f&uuml;r die <mark>Openlist</mark> und eine List f&uuml;r die <mark>Closedlist</mark> angelegt. Noch dazu kommt ein HashSet f&uuml;r die bearbeiteten Units. 
Angefangen wird damit, dass der <mark>Openlist</mark> die Start Unit hinzugef&uuml;gt wird. Die Parent Unit ist dabei nat&uuml;rlich Null, da die Start Unit in der Regel kein Parent hat. 
ProcessedUnits wird die Start Unit auch &uuml;bergeben. 
Solange _conversion nicht die oberste Unit der <mark>Openlist</mark> und die Ziel Unit beinhaltet, bekommt currentItem die oberste Unit aus der <mark>Openlist</mark>, welches gleichzeitig aus der Liste entfernt wird. 
Die Unit von currentItem kommt dann in die <mark>Closedlist</mark>. 
F&uuml;r jedes Element in _conversion wo, x.from das currentItem ist, wird gerpr&uuml;ft ob die processedUnits y.to nicht beinhalten. 
Falls dies der Fall sein sollte, wird der <mark>Openlist</mark> y.to und currentItem hinzugef&uuml;gt. ProcessedUnits wird auch y.to hizugef&uuml;gt.<br />
Danach wird der <mark>Closedlist</mark> die oberste Unit der <mark>Openlist</mark> hinzugef&uuml;gt und es wird der functionStack gemacht. 
Zudem kommt eine neue Node, die currentNode, welche die Ziel Unit und das oberste Element der <mark>Openlist</mark> beinhaltet. 
Solange die Parent Unit der currentNode nicht Null ist, wird die currentNode Unit ausgegeben. 
Der functionStack bekommt oben drauf noch _conversion mit der Parent Unit von currentNode und die Unit von currentNode. 
Danach bekommt die neue currentNode die Unit von der vorherigen Parent Unit zugewiesen. 
Zum Schluss wird noch der functionStack zur&uuml;ckgegeben.  </p>
<p>Bei <strong>AddPath</strong> werden Pfade dem Unit Tree hinzugef&uuml;gt. Solange dies passiert, fuktioniert der Unit Tree nicht, weshalb _functional auch false ist. 
Hierbei wird _conversion die Start und Ziel Unit und conversionFunc &uuml;bergeben.</p>
<pre><code class="language-c#">        public void AddPath(string startUnit, string targetUnit, ConversionFunction conversionFunc)
        {
            _functional = false;
            _conversion.TryAdd((startUnit,targetUnit), conversionFunc);
        }
</code></pre>
<p>Zum Schluss wird noch &uuml;berpr&uuml;ft, ob der <strong>Unit Tree funktioniert</strong>, damit m&ouml;gliche Fehler fr&uuml;hzeitig erkannt werden.</p>
<pre><code class="language-c#">        private void checkFunctionality()
        {
            Dictionary&lt;string,List&lt;string&gt;?&gt; traceBook= new Dictionary&lt;string,List&lt;string&gt;&gt;();
            Queue&lt;string&gt; openNodes = new Queue&lt;string&gt;();
            traceBook.Add(_conversion.First().Key.from,null);
            openNodes.Enqueue(_conversion.First().Key.from);
            do
            {
                foreach (var y in _conversion.Keys.Where(x =&gt; x.from == openNodes.Peek()))
                {
                    if (!traceBook.ContainsKey(y.to))
                    {
                        traceBook.Add(y.to,new List&lt;string&gt;(){y.from});
                        openNodes.Enqueue(y.to);
                    }
                    else if (traceBook[y.to] != null)
                    {
                        traceBook[y.to].Add(y.from);
                    }
                    else if (traceBook[y.from] != null)
                    {
                        Queue&lt;string&gt; backTrace = new Queue&lt;string&gt;();
                        foreach (string parent in traceBook[y.from])
                        {
                            if (traceBook[parent] != null)
                                backTrace.Enqueue(parent);
                        }
                        traceBook[y.from] = null;

                        while (backTrace.Count &gt; 0)
                        {
                            foreach (string parent in traceBook[backTrace.Peek()])
                            {
                                if (traceBook[parent] != null)
                                    backTrace.Enqueue(parent);
                            }
                            traceBook[backTrace.Dequeue()] = null;
                        }
                    }
                }
                openNodes.Dequeue();

            } while (openNodes.Count &gt; 0);


            if (traceBook.Count(x =&gt; x.Value != null) &gt; 0 || 
                traceBook.Count &lt; _conversion.DistinctBy(y =&gt; y.Key.from).Count())
            {
                _functional = false;
            }
            else
            {
                _functional =true;
            }
        }
</code></pre>
<p>Dabei wird zuerst das <mark>Dictionary tracebook</mark> angelegt und eine Queue mit den noch <mark>unbearbeiteten Nodes (openNodes)</mark>. 
Zum tracebook wird zuerst das erste Element 'from' von _conversion und Null hinzugef&uuml;gt. Bei OpenNodes wird dieses erste Element auch hinzugef&uuml;gt.<br />
Danach wird, solange etwas in openNodes drin ist, f&uuml;r jedes Element in _conversion wo x.from gleich das oberste Element von openNodes ist gepr&uuml;ft, ob tracebook y.to nicht beinhaltet. 
Wenn das der Fall sein sollte, dann wird y.to und eine Liste mit y.from dem tracebook hinzugef&uuml;gt. 
Ansonsten, wenn y.to vom tracebook nicht gleich Null ist, dann wird zu y.to vom tracebook y.from hinzugef&uuml;gt. 
Und wenn y.from vom tracebook nicht gleich Null ist, dann wird eine neue Queue mit dem Namen <mark>backtrace</mark> angelegt. 
F&uuml;r jeden parent in backtrace wird &uuml;berpr&uuml;ft, ob dieser Null ist. Wenn dies nicht der Fall sein sollte, dann wird dieser parent dem tracebook hinzugef&uuml;gt. 
Danach wird y.from vom tracebook wieder auf Null gesetzt. 
Solange in backtrace noch Elemente drin sind, wird das oberste Element in backtrace gepr&uuml;ft ob der parent vom tracebook gleich Null ist. 
Sollte dies nicht der Fall sein, dann wird der parent dem backtrace hinzugef&uuml;gt. Danach werden das backtrace und die openNodes noch geleert.<br />
Zum Schluss wird noch gepr&uuml;ft, ob die Anzahl an Values aus tracebook, welche nicht gleich Null sind gr&ouml;&szlig;er als 0 ist 
oder ob das tracebook weniger Elemente hat als _conversion y.from Elemente hat. 
Wenn eine der beiden Bedingungen stimmen sollte, dann wird der Unit Tree nicht funktionieren. Ansonsten wird er funktionieren.</p>
<p>Wenn das <strong>bool _functional</strong> false sein sollte, dann wird der Baum gepr&uuml;ft um zu schauen ob es wirklich false ist. 
Wenn das bool dann immer noch false sein sollte, dann wird einem in der Konsole deutlich gezeigt, dass etwas nicht ganz funktioniert.</p>
<pre><code class="language-c#">        public bool IsFunctional()
        {
            if (!_functional)
            {
                checkFunctionality();
            }
            if (!_functional)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine(&quot;!!!Using not functional UnitTree!!!&quot;);
                Console.ResetColor();
            }
            return _functional;
        }
</code></pre>
<h2 id="calculator">Calculator</h2>
<p>Au&szlig;erdem gibt es eine Klasse, welche die einzelnen Einheiten verwaltet, die Ergebnisse vom Kalkulator sind.<br />
Zum einem die <strong>ben&ouml;tigte Fl&auml;che</strong>, der inneren Schicht, wie auch der &auml;u&szlig;eren Schicht.</p>
<pre><code class="language-c#">        public double CalculateAreaIntern(double ampere, double tRise)
        {
            double I = ampere;
            double TRise = tRise;
            const double constantK = 0.024;
            double constantB = 0.44;
            double constantC = 0.725;
            double area;

            area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC));

            return area;
        }
</code></pre>
<pre><code class="language-c#">        public double CalculateAreaExtern(double ampere, double tRise)
        {
             double I = ampere;
            double TRise = tRise;
            double constantK = 0.048;
            double constantB = 0.44;
            double constantC = 0.725;
            double area;

            area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC));

            return area;
        }
</code></pre>
<p>Und nat&uuml;rlich auch f&uuml;r die <strong>Breite der Leiterbahnen</strong>. Einmal wird dabei mir Mil gerechnet und einmal mit Oz/Ft<sup>2</sup>.</p>
<pre><code class="language-c#">        public double CalculateWidthMil(double area, double thickness)
        {
            double A = area;
            double t = thickness;
            double width;

            width = A / t;

            return width;
        }
</code></pre>
<pre><code class="language-c#">        public double CalculateWidthOzFt(double area, double thickness)
        {
            return CalculateWidthMil(area, thickness * 1.378f);

        }
</code></pre>
<p>Hier wird dann direkt &uuml;berpr&uuml;ft, ob der eingegebene Wert, verwendet werden kann oder ob dieser nicht erlaubt ist.</p>
<pre><code class="language-c#">        public bool CheckInputValue(double ampereValue, double temperatureValue, double ThicknessValue, double traceLengthValue, double temperaturRiseValue)
        {
            double[] InputValue = { ampereValue, temperatureValue, ThicknessValue, traceLengthValue, temperaturRiseValue };

            if(InputValue.Any(x =&gt; x &lt;= 0))
            {
                return false;
            }
            return true;
        }
</code></pre>
<p>Als n&auml;chstes wird auch &uuml;berpr&uuml;ft, ob die eingegebene Unit zul&auml;ssig ist. 
Falls dies nicht der Fall sein sollte, dann gibt das bool false aus.</p>
<pre><code class="language-c#">        public bool CheckInputUnit(double targetUnitTemperature, double targetUnitThickness, double targetUnitTraceLength, double targetUnitTemperaturRise, double targetUnitWidthIntern, double targetUnitWidthExtern)
        {
            int tempResult = 0;
            int tempRiseResult = 0;
            int thickResult = 0;
            int traceLenghtResult = 0;
            int widthInternResult = 0;
            int widthExternResult = 0;

            if (targetUnitTemperature &gt; 0 &amp;&amp; targetUnitThickness &lt; 2 &amp;&amp; targetUnitTemperaturRise &gt; 0 &amp;&amp; targetUnitTemperaturRise &lt; 2)
            {
                tempResult = 1;
                tempRiseResult = 1;
            }
            if (targetUnitThickness &gt; 0 &amp;&amp; targetUnitThickness &lt; 4)
            {
                thickResult = 1;
            }
            if(targetUnitTraceLength &gt; 0 &amp;&amp; targetUnitTraceLength &lt; 7)
            {
                traceLenghtResult = 1;
            }
            if(targetUnitWidthIntern &gt; 0 &amp;&amp; targetUnitWidthIntern &lt; 3 &amp;&amp; targetUnitWidthExtern &gt; 0 &amp;&amp; targetUnitWidthExtern &lt; 3)
            {
                widthInternResult = 1;
                widthExternResult = 1;
            }

            double[] UnitCheck = { tempResult, tempRiseResult, thickResult, traceLenghtResult, widthInternResult, widthExternResult };

            if (UnitCheck.Any(x =&gt; x &lt; 1))
            {
                return false;
            }
            return true;
        }
</code></pre>
<h2 id="testing">Testing</h2>
<p>Um sicher zu stellen, dass alles funktioniert, haben wir mit Unit Tests verschiedene Methoden und Klassen getestet. 
Zum einen wurde der Calculator getestet, die Pr&auml;fixe wurden getestet und es wurden Tests mit verschiedenen Zahlen gemacht. 
Zudem wird zus&auml;tzlich &uuml;berpr&uuml;ft, ob der Unit Tree funktioniert, da dieser eins der wichtigsten Elemente der Klasse ist.  </p>
<p><strong>Calculator Test</strong><br />
Um den Unit Tree zu Testen gibt es viele Funktionen, um sicher zu stellen, dass keine Fehler auftauchen k&ouml;nnen.<br />
Zuerst wird &uuml;berpr&uuml;ft, ob die Konvertierung der Einheiten funktioniert. 
Dabei werden alle Einheiten benutzt, um eine M&ouml;glichkeiten zu beinhalten.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckSelfConversion()
        {
            UnitTree Converter = new UnitTree();

            Converter.AddPath(&quot;cm&quot;, &quot;mym&quot;, x =&gt; x * 10000);
            Converter.AddPath(&quot;cm&quot;, &quot;mm&quot;, x =&gt; x * 10.0);
            Converter.AddPath(&quot;cm&quot;, &quot;m&quot;, x =&gt; x / 100.0);
            Converter.AddPath(&quot;cm&quot;, &quot;in&quot;, x =&gt; x / 2.54);
            Converter.AddPath(&quot;cm&quot;, &quot;ft&quot;, x =&gt; x / 30.48);
            Converter.AddPath(&quot;mym&quot;, &quot;cm&quot;, x =&gt; x / 10000);
            Converter.AddPath(&quot;m&quot;, &quot;cm&quot;, x =&gt; x * 100.0);
            Converter.AddPath(&quot;mm&quot;, &quot;cm&quot;, x =&gt; x / 10.0);
            Converter.AddPath(&quot;in&quot;, &quot;cm&quot;, x =&gt; x * 2.54);
            Converter.AddPath(&quot;ft&quot;, &quot;cm&quot;, x =&gt; x * 30.48);
            Converter.AddPath(&quot;mil&quot;, &quot;in&quot;, x =&gt; x / 1000);
            Converter.AddPath(&quot;in&quot;, &quot;mil&quot;, x =&gt; x * 1000);
            Converter.AddPath(&quot;oz/ft^2&quot;, &quot;mil&quot;, x =&gt; x / 1.37f);
            Converter.AddPath(&quot;mil&quot;, &quot;oz/ft^2&quot;, x =&gt; x * 1.37f);
            Converter.AddPath(&quot;mm&quot;, &quot;mil&quot;, x =&gt; x * 39.37f);
            Converter.AddPath(&quot;mil&quot;, &quot;mm&quot;, x =&gt; x / 39.37f);
            Converter.AddPath(&quot;mm&quot;, &quot;mym&quot;, x =&gt; x * 1000f);
            Converter.AddPath(&quot;mym&quot;, &quot;mm&quot;, x =&gt; x / 1000f);
            Converter.AddPath(&quot;F&quot;, &quot;C&quot;, x =&gt; (x - 32) * 5 / 9.0);
            Converter.AddPath(&quot;C&quot;, &quot;F&quot;, x =&gt; (x * 1.8 + 32));

            string[] StartUnits = new string[] { &quot;mym&quot;, &quot;mm&quot;, &quot;cm&quot;, &quot;m&quot;, &quot;in&quot;, &quot;ft&quot;, &quot;mil&quot;,&quot;oz/ft^2&quot;,&quot;F&quot;,&quot;C&quot; };
            string[] EndUnits = new string[] { &quot;mym&quot;, &quot;mm&quot;, &quot;cm&quot;, &quot;m&quot;, &quot;in&quot;, &quot;ft&quot;, &quot;mil&quot;,&quot;oz/ft^2&quot;,&quot;F&quot;, &quot;C&quot; };

            for (int i = 0; i &lt; StartUnits.Length; i++)
            {
                double number = Converter.ConvertValue(StartUnits[i], EndUnits[i], 1);
                Assert.AreEqual(1, number);
            }
        }
</code></pre>
<p>Hier werden dann die Werte der Konvertierungen &uuml;berpr&uuml;ft. 
Wenn ein Ergebnis nicht dem vorgesehenen Wert entspricht, dann schl&auml;gt der Test fehl.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckLengthConversion()
        {
            UnitTree Converter = new UnitTree();

            Converter.AddPath(&quot;cm&quot;, &quot;mym&quot;, x =&gt; x * 10000);
            Converter.AddPath(&quot;cm&quot;, &quot;mm&quot;, x =&gt; x * 10.0);
            Converter.AddPath(&quot;cm&quot;, &quot;m&quot;, x =&gt; x / 100.0);
            Converter.AddPath(&quot;cm&quot;, &quot;in&quot;, x =&gt; x / 2.54);
            Converter.AddPath(&quot;cm&quot;, &quot;ft&quot;, x =&gt; x / 30.48);
            Converter.AddPath(&quot;mym&quot;, &quot;cm&quot;, x =&gt; x / 10000);
            Converter.AddPath(&quot;m&quot;, &quot;cm&quot;, x =&gt; x * 100.0);
            Converter.AddPath(&quot;mm&quot;, &quot;cm&quot;, x =&gt; x / 10.0);
            Converter.AddPath(&quot;in&quot;, &quot;cm&quot;, x =&gt; x * 2.54);
            Converter.AddPath(&quot;ft&quot;, &quot;cm&quot;, x =&gt; x * 30.48);
            Converter.AddPath(&quot;mil&quot;, &quot;in&quot;, x =&gt; x / 1000);
            Converter.AddPath(&quot;in&quot;, &quot;mil&quot;, x =&gt; x * 1000);


            double conversion1 = Converter.ConvertValue(&quot;mm&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(1000, conversion1);
            double conversion2 = Converter.ConvertValue(&quot;mm&quot;, &quot;cm&quot;, 1);
            Assert.AreEqual(0.1, conversion2);
            double conversion3 = Converter.ConvertValue(&quot;mm&quot;, &quot;m&quot;, 1);
            Assert.AreEqual(0.001, conversion3);
            double conversion4 = Converter.ConvertValue(&quot;mm&quot;, &quot;in&quot;, 1);
            Assert.AreEqual(0.03937007874015748, conversion4);
            double conversion5 = Converter.ConvertValue(&quot;mm&quot;, &quot;ft&quot;, 1);
            Assert.AreEqual(0.0032808398950131233, conversion5);
            double conversion6 = Converter.ConvertValue(&quot;mm&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(39.37007874015748, conversion6);

            double conversion7 = Converter.ConvertValue(&quot;cm&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(10, conversion7);
            double conversion8 = Converter.ConvertValue(&quot;cm&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(10000, conversion8);
            double conversion9 = Converter.ConvertValue(&quot;cm&quot;, &quot;m&quot;, 1);
            Assert.AreEqual(0.01, conversion9);
            double conversion10 = Converter.ConvertValue(&quot;cm&quot;, &quot;in&quot;, 1);
            Assert.AreEqual(0.39370078740157477, conversion10);
            double conversion11 = Converter.ConvertValue(&quot;cm&quot;, &quot;ft&quot;, 1);
            Assert.AreEqual(0.03280839895013123, conversion11);
            double conversion12 = Converter.ConvertValue(&quot;cm&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(393.70078740157476, conversion12);

            double conversion13 = Converter.ConvertValue(&quot;m&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(1000, conversion13);
            double conversion14 = Converter.ConvertValue(&quot;m&quot;, &quot;cm&quot;, 1);
            Assert.AreEqual(100, conversion14);
            double conversion15 = Converter.ConvertValue(&quot;m&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(1e+6, conversion15);
            double conversion16 = Converter.ConvertValue(&quot;m&quot;, &quot;in&quot;, 1);
            Assert.AreEqual(39.37007874015748, conversion16);
            double conversion17 = Converter.ConvertValue(&quot;m&quot;, &quot;ft&quot;, 1);
            Assert.AreEqual(3.2808398950131235, conversion17);
            double conversion18 = Converter.ConvertValue(&quot;m&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(39370.07874015748, conversion18);

            double conversion19 = Converter.ConvertValue(&quot;in&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(25.4, conversion19);
            double conversion20 = Converter.ConvertValue(&quot;in&quot;, &quot;cm&quot;, 1);
            Assert.AreEqual(2.54, conversion20);
            double conversion21 = Converter.ConvertValue(&quot;in&quot;, &quot;m&quot;, 1);
            Assert.AreEqual(0.0254, conversion21);
            double conversion22 = Converter.ConvertValue(&quot;in&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(25400, conversion22);
            double conversion23 = Converter.ConvertValue(&quot;in&quot;, &quot;ft&quot;, 1);
            Assert.AreEqual(0.08333333333333333, conversion23);
            double conversion24 = Converter.ConvertValue(&quot;in&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(1000, conversion24);

            double conversion25 = Converter.ConvertValue(&quot;ft&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(304.8, conversion25);
            double conversion26 = Converter.ConvertValue(&quot;ft&quot;, &quot;cm&quot;, 1);
            Assert.AreEqual(30.48, conversion26);
            double conversion27 = Converter.ConvertValue(&quot;ft&quot;, &quot;m&quot;, 1);
            Assert.AreEqual(0.3048, conversion27);
            double conversion28 = Converter.ConvertValue(&quot;ft&quot;, &quot;in&quot;, 1);
            Assert.AreEqual(12, conversion28);
            double conversion29 = Converter.ConvertValue(&quot;ft&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(304800, conversion29);
            double conversion30 = Converter.ConvertValue(&quot;ft&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(12000, conversion30);

            double conversion31 = Converter.ConvertValue(&quot;mil&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(0.025400000000000002, conversion31);
            double conversion32 = Converter.ConvertValue(&quot;mil&quot;, &quot;cm&quot;, 1);
            Assert.AreEqual(0.00254, conversion32);
            double conversion33 = Converter.ConvertValue(&quot;mil&quot;, &quot;m&quot;, 1);
            Assert.AreEqual(2.54e-5, conversion33);
            double conversion34 = Converter.ConvertValue(&quot;mil&quot;, &quot;in&quot;, 1);
            Assert.AreEqual(0.001, conversion34);
            double conversion35 = Converter.ConvertValue(&quot;mil&quot;, &quot;ft&quot;, 1);
            Assert.AreEqual(8.333333333333333E-05, conversion35);
            double conversion36 = Converter.ConvertValue(&quot;mil&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(25.400000000000002, conversion36);
        }
</code></pre>
<p>Im Folgenden werden die einzelnen Konvertierungen dann nochmal genauer &uuml;berpr&uuml;ft, angefangen bei der Temperatur.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckTemperatureConversion()
        {
            UnitTree Converter = new UnitTree();
            Converter.AddPath(&quot;F&quot;, &quot;C&quot;, x =&gt; (x - 32) * 5 / 9.0);
            Converter.AddPath(&quot;C&quot;, &quot;F&quot;, x =&gt; (x * 1.8 + 32));

            double conversion1 = Converter.ConvertValue(&quot;F&quot;, &quot;C&quot;, 25);
            Assert.AreEqual(-3.888888888888889, conversion1);
            double conversion2 = Converter.ConvertValue(&quot;C&quot;, &quot;F&quot;, 25);
            Assert.AreEqual(77, conversion2);
        }
</code></pre>
<p>Danach kommt die Konvertierung der Dicke.</p>
<pre><code class="language-c#">
        [TestMethod]
        public void CheckThicknessConversion()
        {
            UnitTree Converter = new UnitTree();

            Converter.AddPath(&quot;oz/ft^2&quot;, &quot;mil&quot;, x =&gt; x / 1.37f);
            Converter.AddPath(&quot;mil&quot;, &quot;oz/ft^2&quot;, x =&gt; x * 1.37f);
            Converter.AddPath(&quot;mm&quot;, &quot;mil&quot;, x =&gt; x * 39.37f);
            Converter.AddPath(&quot;mil&quot;, &quot;mm&quot;, x =&gt; x / 39.37f);
            Converter.AddPath(&quot;mm&quot;, &quot;mym&quot;, x =&gt; x * 1000f);
            Converter.AddPath(&quot;mym&quot;, &quot;mm&quot;, x =&gt; x / 1000f);

            double conversion1 = Converter.ConvertValue(&quot;oz/ft^2&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(0.729927004758713, conversion1);
            double conversion2 = Converter.ConvertValue(&quot;oz/ft^2&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(0.01854018350423585, conversion2);
            double conversion3 = Converter.ConvertValue(&quot;oz/ft^2&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(18.54018350423585, conversion3);

            double conversion4 = Converter.ConvertValue(&quot;mil&quot;, &quot;oz/ft^2&quot;, 1);
            Assert.AreEqual(1.3700000047683716, conversion4);
            double conversion5 = Converter.ConvertValue(&quot;mil&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(0.0254000514892096, conversion5);
            double conversion6 = Converter.ConvertValue(&quot;mil&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(25.4000514892096, conversion6);

            double conversion7 = Converter.ConvertValue(&quot;mm&quot;, &quot;oz/ft^2&quot;, 1);
            Assert.AreEqual(53.93689872441291, conversion7);
            double conversion8 = Converter.ConvertValue(&quot;mm&quot;, &quot;mym&quot;, 1);
            Assert.AreEqual(1000, conversion8);
            double conversion9 = Converter.ConvertValue(&quot;mm&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(39.369998931884766, conversion9);

            double conversion10 = Converter.ConvertValue(&quot;mym&quot;, &quot;mil&quot;, 1);
            Assert.AreEqual(0.03936999893188477, conversion10);
            double conversion11 = Converter.ConvertValue(&quot;mym&quot;, &quot;mm&quot;, 1);
            Assert.AreEqual(0.001, conversion11);
            double conversion12 = Converter.ConvertValue(&quot;mym&quot;, &quot;oz/ft^2&quot;, 1);
            Assert.AreEqual(0.053936898724412916, conversion12);
        }
</code></pre>
<p>Als n&auml;chstes wird die Calculator Klasse getestet. 
Dabei werden die Ergebnisse der Methoden mit einem erwarteten Wert verglichen und so &uuml;berpr&uuml;ft ob bei den Rechungen, das richtige rauskommt.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckLayerCalculation()
        {
            Calculator Calculator = new Calculator();

            double areaIntern = Calculator.CalculateAreaIntern(1, 10);
            double areaExtern = Calculator.CalculateAreaExtern(1, 10);

            Assert.AreEqual(42.39306714892737, areaIntern);
            Assert.AreEqual(16.296001347209486, areaExtern);

            double widthInternMil = Calculator.CalculateWidthMil(areaIntern, 1);
            double widthInternOzFt = Calculator.CalculateWidthOzFt(areaIntern, 1);

            Assert.AreEqual(42.39306714892737, widthInternMil);
            Assert.AreEqual(30.764199204258915, widthInternOzFt);

            double widthExternMil = Calculator.CalculateWidthMil(areaExtern, 1);
            double widthExternOzFt = Calculator.CalculateWidthOzFt(areaExtern, 1);

            Assert.AreEqual(16.296001347209486, widthExternMil);
            Assert.AreEqual(11.825835340416246, widthExternOzFt);
        }
</code></pre>
<p>Hier wird getestet, ob Klasse negative Zahlen nicht annimmt, da mit diesen kein korrektes Ergebnis geliefert werden k&ouml;nnte.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckInputValueCheck()
        {
            Calculator Calculator = new Calculator();

            Assert.IsTrue(Calculator.CheckInputValue(1, 1, 1, 1, 1));
            Assert.IsFalse(Calculator.CheckInputValue(-1, 1, 1, 1, 1));
            Assert.IsFalse(Calculator.CheckInputValue(1, -1, 1, 1, 1));
            Assert.IsFalse(Calculator.CheckInputValue(1, 1, -1, 1, 1));
            Assert.IsFalse(Calculator.CheckInputValue(1, 1, 1, -1, 1));
            Assert.IsFalse(Calculator.CheckInputValue(1, 1, 1, 1, -1));
        }
</code></pre>
<p>Als n&auml;chstes wird geschaut, was passiert wenn man 0 als Wert angibt und ob die Klasse diesen Wert auch nicht annimmt.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckInputUnitCheck()
        {
           // Exception WrongInput;

            Calculator Calculator = new Calculator();
            Assert.IsTrue(Calculator.CheckInputUnit(1,1,1,1,1,1));
            Assert.IsFalse(Calculator.CheckInputUnit(0,1,1,1,1,1));
            Assert.IsFalse(Calculator.CheckInputUnit(1,0,1,1,1,1));
            Assert.IsFalse(Calculator.CheckInputUnit(1,1,0,1,1,1));
            Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,0,1,1));
            Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,1,0,1));
            Assert.IsFalse(Calculator.CheckInputUnit(1,1,1,1,1,0));
        }
</code></pre>
<p>In dem n&auml;chsten Test wird &uuml;berpr&uuml;ft ob der Unit Tree so funktioniert wie er soll und keine L&uuml;cken aufweist. 
Es wird getestet, was passiert, wenn der Unit Tree keinen Rundlauf hat, wenn es eine schwebene Verbindung gibt und wenn er theoretisch funktionieren sollte. 
Sind die ersten beiden Test falsch und der letzte richtig, dann funktioniert der Unit Tree wie gedacht.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckFunctionality()
        {
            //kein Rundlauf
            UnitTree unitTree = new UnitTree();
            unitTree.AddPath(&quot;m&quot;, &quot;cm&quot;, x =&gt; x * 100.0); 
            Assert.IsFalse(unitTree.IsFunctional());

            //schwebende Verbindung
            UnitTree unitTree2 = new UnitTree();
            unitTree2.AddPath(&quot;m&quot;, &quot;cm&quot;, x =&gt; x * 100.0);
            unitTree2.AddPath(&quot;cm&quot;, &quot;m&quot;, x =&gt; x / 100);
            unitTree2.AddPath(&quot;mm&quot;, &quot;dm&quot;, x =&gt; x / 100);
            Assert.IsFalse(unitTree2.IsFunctional());

            //funktionierender Tree
            UnitTree unitTree3 = new UnitTree();
            unitTree3.AddPath(&quot;m&quot;, &quot;cm&quot;, x =&gt; x * 100.0);
            unitTree3.AddPath(&quot;cm&quot;, &quot;m&quot;, x =&gt; x / 100);
            unitTree3.AddPath(&quot;cm&quot;, &quot;mm&quot;, x =&gt; x / 10);
            unitTree3.AddPath(&quot;mm&quot;, &quot;dm&quot;, x =&gt; x / 100);
            unitTree3.AddPath(&quot;dm&quot;, &quot;m&quot;, x =&gt; x / 10);
            Assert.IsTrue(unitTree3.IsFunctional());
        }
</code></pre>
<p>In diesem Test werden die Pr&auml;fixe &uuml;berpr&uuml;ft, um zu wissen ob ihre Werte stimmen.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckPrefixValue()
        {
            SIPrefix[] s = new SIPrefix[] {SIPrefix.Quekto, SIPrefix.Ronto, SIPrefix.Yokto, SIPrefix.Zepto, SIPrefix.Atto
                                            , SIPrefix.Femto, SIPrefix.Piko, SIPrefix.Nani, SIPrefix.Mikro, SIPrefix.Milli, SIPrefix.SIDefault,
                                            SIPrefix.Kilo, SIPrefix.Mega, SIPrefix.Giga, SIPrefix.Tera, SIPrefix.Peta, SIPrefix.Exa, SIPrefix.Zetta
                                            , SIPrefix.Yotta, SIPrefix.Ronna, SIPrefix.Quetta};

            int j = -30;

            foreach(SIPrefix i in s)
            {
                Assert.AreEqual(j,((int)i));
                j += 3;
            }

            SIPrefix[] k = new SIPrefix[] { SIPrefix.Hekto, SIPrefix.Deka, SIPrefix.SIDefault, SIPrefix.Dezi, SIPrefix.Zenti };

            int l = 2;

            foreach(SIPrefix m in k)
            {
                Assert.AreEqual(l, (int)m);
                l -= 1;
            }
        }
</code></pre>
<p>Es wird auch getestet, ob die Konvertierung der Pr&auml;fixe fehlerfrei funktioniert, damit sich keine Fehler unbemerkt durch das Programm ziehen.</p>
<pre><code class="language-c#">        [TestMethod]
        public void CheckConvertSIPrefix()
        {
            UnitTree unitTree = new UnitTree();
            SIPrefix[] positiv = new SIPrefix[] {SIPrefix.Kilo, SIPrefix.Mega, 
                                                    SIPrefix.Giga, SIPrefix.Tera, SIPrefix.Peta, SIPrefix.Exa, SIPrefix.Zetta
                                                , SIPrefix.Yotta, SIPrefix.Ronna, SIPrefix.Quetta};

            SIPrefix[] negative = new SIPrefix[] { SIPrefix.Milli, SIPrefix.Mikro, SIPrefix.Nani, SIPrefix.Piko, SIPrefix.Femto,
                                                     SIPrefix.Atto,  SIPrefix.Zepto, SIPrefix.Yokto, SIPrefix.Ronto, SIPrefix.Quekto, };

            SIPrefix[] positiveClose = new SIPrefix[] { SIPrefix.SIDefault, SIPrefix.Deka, SIPrefix.Hekto };

            SIPrefix[] negativeClose = new SIPrefix[] { SIPrefix.SIDefault, SIPrefix.Dezi, SIPrefix.Zenti };

            double k = 1e+3;
            double l = 1e-3;
            double n = 1e+0;
            double m = 1e-0;

            foreach (SIPrefix i in positiv)
            {
                 Assert.AreEqual(k, unitTree.ConvertSIPrefixValue(&quot;m&quot;, SIPrefix.SIDefault, &quot;m&quot;, i, 1));
                 k *= 1000;
            }

            foreach (SIPrefix i in negative)
            {
                Assert.AreEqual(l, unitTree.ConvertSIPrefixValue(&quot;m&quot;, SIPrefix.SIDefault, &quot;m&quot;, i, 1), l * 0.001);
                l /= 1000;
            }

            foreach (SIPrefix i in positiveClose)
            {
                Assert.AreEqual(n, unitTree.ConvertSIPrefixValue(&quot;m&quot;, SIPrefix.SIDefault, &quot;m&quot;, i, 1));
                n *= 10;
            }

            foreach (SIPrefix i in negativeClose)
            {
                Assert.AreEqual(m, unitTree.ConvertSIPrefixValue(&quot;m&quot;, SIPrefix.SIDefault, &quot;m&quot;, i, 1));
                m /= 10;
            }
        }        
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
