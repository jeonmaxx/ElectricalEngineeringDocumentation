<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://jeonmaxx.github.io/ElectricalEngineeringDocumentation/traceWidths/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Leiterbahnbreiten - Electrical Engineering Toolbox</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Electrical Engineering Toolbox</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../resistance/" class="nav-link">Widerstand</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Leiterbahnbreiten</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../resistance/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#leiterbahnbreiten" class="nav-link">Leiterbahnbreiten</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#einleitung" class="nav-link">Einleitung</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#unittree" class="nav-link">UnitTree</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#calculator" class="nav-link">Calculator</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#testing" class="nav-link">Testing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="leiterbahnbreiten">Leiterbahnbreiten</h1>
<h2 id="einleitung">Einleitung</h2>
<p>In diesem Teil wird die Benutzung, der <mark>Leiterbahnbreiten Tools</mark> erkl&auml;rt. 
Um die verschiedenen Einheiten und Gr&ouml;&szlig;en zu verwalten wurde ein <strong>Unit Tree</strong> benutzt, damit eine gute Performance zu gew&auml;hrleistet wird. 
Desweiteren wird die <strong>Calculator</strong> Klasse benutzt, um die Ergebniss Einheiten zu verwalten.</p>
<h2 id="unittree">UnitTree</h2>
<p>Als erstes besitzt der Unit Tree ein Enum, welches alle vorhandenen <strong>SI-Pr&auml;fixe</strong> enth&auml;lt. 
Diese w&auml;ren nat&uuml;rlich erweiterbar, falls jemals welche dazu kommen sollten.
Zudem besitzt das Enum einen Default, da die Pr&auml;fixe nicht immer ben&ouml;tigt werden.</p>
<pre><code class="language-c#">        public enum SIPrefix
        {
            Quetta = 30,
            Ronna = 27,
            Yotta = 24,
            Zetta = 21,
            Exa = 18,
            Peta = 15,
            Tera = 12,
            Giga = 9,
            Mega = 6,
            Kilo = 3,
            Hekto = 2,
            Deka = 1,
            SIDefault = 0,
            Dezi = -1,
            Zenti = -2,
            Milli = -3,
            Mikro = -6,
            Nani = -9,
            Piko = -12,
            Femot = -15,
            Atto = -18,
            Zepto = -21,
            Yokto = -24,
            Ronto = -27,
            Quekto = -30
        }
</code></pre>
<p>Danach beginnt auch schon der Unit Tree mit einer Klassen f&uuml;r die <strong>Nodes</strong>. 
Die Klasse besitzt zum einem einen String mit der Unit und auch der Parent Unit. 
Ein Node besteht dabei immer aus einer Unit und dessen Parent Unit.</p>
<pre><code class="language-c#">        private class Node
        {
            public readonly string Unit;
            public readonly Node? ParentUnit;

            public Node(string unit, Node? parentUnit)
            {
                Unit = unit;
                ParentUnit = parentUnit;
            }

            public override string ToString()
            {
                return Unit;
            }

            public bool HasUnit(string unit)
            {
                return unit == Unit;
            }
        }
</code></pre>
<p>Nach der Node Klasse, folgt die <strong>BackTraceNode</strong> Klasse. 
Diese ist vorallem wichtig, um zu &uuml;berpr&uuml;fen, ob der Unit Tree funktioniert. 
Sie besteht aus einem string, welcher die aktuelle Unit beihaltet und einer Liste mit dem Parent Units.</p>
<pre><code class="language-c#">        private class BackTraceNode
        {
            public readonly string Unit;
            public List&lt;Node&gt; ParentUnits;

            public BackTraceNode(string unit)
            {
                Unit = unit;
            }

            public override string ToString()
            {
                return Unit;
            }

            public bool HasUnit(string unit)
            {
                return unit == Unit;
            }
        }
</code></pre>
<p>Als n&auml;chstes folgt eine Methode, f&uuml;r die <strong>Konvertierung der SI-Pr&auml;fixe</strong>. 
Sie ben&ouml;tigt die Start und Ziel Unit, sowie den Start und Target Pr&auml;fix. 
Zudem muss auch ein Wert angegeben werden. 
Dann werden die Start und Ziel Unit an ConvertValue &uuml;bergeben. 
Der angegebene Wert wird dann mit 10<sup>StartPr&auml;fix</sup> mal 10<sup>ZielPr&auml;fix</sup> mal genommen und auch an ConvertValue &uuml;bergeben.</p>
<pre><code class="language-c#">        public double ConvertSIPrefixValue(string startUnit, SIPrefix startPrefix, string targetUnit,
            SIPrefix targetPrefix, double value)
        {
            return ConvertValue(startUnit, targetUnit, value * Math.Pow(10.0, (double) startPrefix)) *
                   Math.Pow(10.0, (double) targetPrefix);
        }
</code></pre>
<p>Hier ist eine Methode, welche dann den <strong>Wert konvertiert</strong>. </p>
<pre><code class="language-c#">        public double ConvertValue(string startUnit, string targetUnit, double value)
        {
            IsFunctional();

            if (startUnit.Equals(targetUnit))
            {
                return value;
            }

            if (_conversion.ContainsKey((startUnit,targetUnit)))
            {
                return _conversion[(startUnit, targetUnit)].Invoke(value);
            }

            Stack&lt;ConversionFunction&gt; functionStack = CreateConversionStack(startUnit, targetUnit);

            while (functionStack.Count &gt; 0)
            {
                value = functionStack.Pop().Invoke(value);
                Console.WriteLine(value);
            }

            return value;
        }
</code></pre>
<p>Zuerst wird gepr&uuml;ft, ob der Unit Tree auch funktioniert. 
Wenn die Start Unit gleich die Ziel Unit ist, dann wird der Wert direkt ausgegeben. 
Dann wird gepr&uuml;ft, ob die Start und Ziel Unit bereits in _conversion vorhanden sind. 
Danach wird ein functionStack gemacht, mit der Start und Ziel Unit. 
Solange dieser Stack gr&ouml;&szlig;er als 0 ist, wird das oberste Element vom Stack ausgegeben.  </p>
<p>Hier wird viel mit dem Unit Tree gearbeitet, um von der <mark>Start Unit zur Ziel Unit</mark> zu gelangen.</p>
<pre><code class="language-c#">        Stack&lt;ConversionFunction&gt; CreateConversionStack(string startUnit, string targetUnit)
        {
            Queue&lt;Node&gt; openQueue = new Queue&lt;Node&gt;();
            List&lt;Node&gt; closedList = new List&lt;Node&gt;();
            HashSet&lt;string&gt; processedUnits = new HashSet&lt;string&gt;();

            openQueue.Enqueue(new Node(startUnit, null));
            processedUnits.Add(startUnit);

            while (!_conversion.ContainsKey((openQueue.Peek().Unit, targetUnit)))
            {
                Node currentItem = openQueue.Dequeue();
                closedList.Add(currentItem);
                foreach (var y in _conversion.Keys.Where(x =&gt; x.from == currentItem.ToString()))
                {
                    if (!processedUnits.Contains(y.to))
                    {
                        openQueue.Enqueue(new Node(y.to, currentItem));
                        processedUnits.Add(y.to);
                    }
                }
            }

            closedList.Add(openQueue.Peek());
            Stack&lt;ConversionFunction&gt; functionStack = new Stack&lt;ConversionFunction&gt;();
            Node currentNode = new Node(targetUnit, openQueue.Peek());

            while (currentNode.ParentUnit != null)
            {
                Console.WriteLine(currentNode.Unit);
                functionStack.Push(_conversion[(currentNode.ParentUnit.Unit, currentNode.Unit)]);
                currentNode = currentNode.ParentUnit;
            }

            return functionStack;
        }
</code></pre>
<p>Zuerst wird eine Queue f&uuml;r die <mark>Openlist</mark> und eine List f&uuml;r die <mark>Closedlist</mark> angelegt. Noch dazu kommt ein HashSet f&uuml;r die bearbeiteten Units. 
Angefangen wird damit, dass der <mark>Openlist</mark> die Start Unit hinzugef&uuml;gt wird. Die Parent Unit ist dabei nat&uuml;rlich Null, da die Start Unit in der Regel kein Parent hat. 
ProcessedUnits wird die Start Unit auch &uuml;bergeben. 
Solange _conversion nicht die oberste Unit der <mark>Openlist</mark> und die Ziel Unit beinhaltet, bekommt currentItem die oberste Unit aus der <mark>Openlist</mark>, welches gleichzeitig aus der Liste entfernt wird. 
Die Unit von currentItem kommt dann in die <mark>Closedlist</mark>. 
F&uuml;r jedes Element in _conversion wo, x.from das currentItem ist, wird gerpr&uuml;ft ob die processedUnits y.to nicht beinhalten. 
Falls dies der Fall sein sollte, wird der <mark>Openlist</mark> y.to und currentItem hinzugef&uuml;gt. ProcessedUnits wird auch y.to hizugef&uuml;gt.<br />
Danach wird der <mark>Closedlist</mark> die oberste Unit der <mark>Openlist</mark> hinzugef&uuml;gt und es wird der functionStack gemacht. 
Zudem kommt eine neue Node, die currentNode, welche die Ziel Unit und das oberste Element der <mark>Openlist</mark> beinhaltet. 
Solange die Parent Unit der currentNode nicht Null ist, wird die currentNode Unit ausgegeben. 
Der functionStack bekommt oben drauf noch _conversion mit der Parent Unit von currentNode und die Unit von currentNode. 
Danach bekommt die neue currentNode die Unit von der vorherigen Parent Unit zugewiesen. 
Zum Schluss wird noch der functionStack zur&uuml;ckgegeben.  </p>
<p>Bei <strong>AddPath</strong> werden Pfade dem Unit Tree hinzugef&uuml;gt. Solange dies passiert, fuktioniert der Unit Tree nicht, weshalb _functional auch false ist. 
Hierbei wird _conversion die Start und Ziel Unit und conversionFunc &uuml;bergeben.</p>
<pre><code class="language-c#">        public void AddPath(string startUnit, string targetUnit, ConversionFunction conversionFunc)
        {
            _functional = false;
            _conversion.TryAdd((startUnit,targetUnit), conversionFunc);
        }
</code></pre>
<p>Zum Schluss wird noch &uuml;berpr&uuml;ft, ob der <strong>Unit Tree funktioniert</strong>, damit m&ouml;gliche Fehler fr&uuml;hzeitig erkannt werden.</p>
<pre><code class="language-c#">        private void checkFunctionality()
        {
            Dictionary&lt;string,List&lt;string&gt;?&gt; traceBook= new Dictionary&lt;string,List&lt;string&gt;&gt;();
            Queue&lt;string&gt; openNodes = new Queue&lt;string&gt;();
            traceBook.Add(_conversion.First().Key.from,null);
            openNodes.Enqueue(_conversion.First().Key.from);
            do
            {
                foreach (var y in _conversion.Keys.Where(x =&gt; x.from == openNodes.Peek()))
                {
                    if (!traceBook.ContainsKey(y.to))
                    {
                        traceBook.Add(y.to,new List&lt;string&gt;(){y.from});
                        openNodes.Enqueue(y.to);
                    }
                    else if (traceBook[y.to] != null)
                    {
                        traceBook[y.to].Add(y.from);
                    }
                    else if (traceBook[y.from] != null)
                    {
                        Queue&lt;string&gt; backTrace = new Queue&lt;string&gt;();
                        foreach (string parent in traceBook[y.from])
                        {
                            if (traceBook[parent] != null)
                                backTrace.Enqueue(parent);
                        }
                        traceBook[y.from] = null;

                        while (backTrace.Count &gt; 0)
                        {
                            foreach (string parent in traceBook[backTrace.Peek()])
                            {
                                if (traceBook[parent] != null)
                                    backTrace.Enqueue(parent);
                            }
                            traceBook[backTrace.Dequeue()] = null;
                        }
                    }
                }
                openNodes.Dequeue();

            } while (openNodes.Count &gt; 0);


            if (traceBook.Count(x =&gt; x.Value != null) &gt; 0 || 
                traceBook.Count &lt; _conversion.DistinctBy(y =&gt; y.Key.from).Count())
            {
                _functional = false;
            }
            else
            {
                _functional =true;
            }
        }
</code></pre>
<p>Dabei wird zuerst das <mark>Dictionary tracebook</mark> angelegt und eine Queue mit den noch <mark>unbearbeiteten Nodes (openNodes)</mark>. 
Zum tracebook wird zuerst das erste Element 'from' von _conversion und Null hinzugef&uuml;gt. Bei OpenNodes wird dieses erste Element auch hinzugef&uuml;gt.<br />
Danach wird, solange etwas in openNodes drin ist, f&uuml;r jedes Element in _conversion wo x.from gleich das oberste Element von openNodes ist gepr&uuml;ft, ob tracebook y.to nicht beinhaltet. 
Wenn das der Fall sein sollte, dann wird y.to und eine Liste mit y.from dem tracebook hinzugef&uuml;gt. 
Ansonsten, wenn y.to vom tracebook nicht gleich Null ist, dann wird zu y.to vom tracebook y.from hinzugef&uuml;gt. 
Und wenn y.from vom tracebook nicht gleich Null ist, dann wird eine neue Queue mit dem Namen <mark>backtrace</mark> angelegt. 
F&uuml;r jeden parent in backtrace wird &uuml;berpr&uuml;ft, ob dieser Null ist. Wenn dies nicht der Fall sein sollte, dann wird dieser parent dem tracebook hinzugef&uuml;gt. 
Danach wird y.from vom tracebook wieder auf Null gesetzt. 
Solange in backtrace noch Elemente drin sind, wird das oberste Element in backtrace gepr&uuml;ft ob der parent vom tracebook gleich Null ist. 
Sollte dies nicht der Fall sein, dann wird der parent dem backtrace hinzugef&uuml;gt. Danach werden das backtrace und die openNodes noch geleert.<br />
Zum Schluss wird noch gepr&uuml;ft, ob die Anzahl an Values aus tracebook, welche nicht gleich Null sind gr&ouml;&szlig;er als 0 ist 
oder ob das tracebook weniger Elemente hat als _conversion y.from Elemente hat. 
Wenn eine der beiden Bedingungen stimmen sollte, dann wird der Unit Tree nicht funktionieren. Ansonsten wird er funktionieren.</p>
<p>Wenn das <strong>bool _functional</strong> false sein sollte, dann wird der Baum gepr&uuml;ft um zu schauen ob es wirklich false ist. 
Wenn das bool dann immer noch false sein sollte, dann wird einem in der Konsole deutlich gezeigt, dass etwas nicht ganz funktioniert.</p>
<pre><code class="language-c#">        public bool IsFunctional()
        {
            if (!_functional)
            {
                checkFunctionality();
            }
            if (!_functional)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine(&quot;!!!Using not functional UnitTree!!!&quot;);
                Console.ResetColor();
            }
            return _functional;
        }
</code></pre>
<h2 id="calculator">Calculator</h2>
<p>Au&szlig;erdem gibt es eine Klasse, welche die einzelnen Einheiten verwaltet, die Ergebnisse vom Kalkulator sind.<br />
Zum einem die <strong>ben&ouml;tigte Fl&auml;che</strong>, der inneren Schicht, wie auch der &auml;u&szlig;eren Schicht.</p>
<pre><code class="language-c#">        public double CalculateAreaIntern(double ampere, double tRise)
        {
            double I = ampere;
            double TRise = tRise;
            double constantK = 0.024;
            double constantB = 0.44;
            double constantC = 0.725;
            double area;

            area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC));

            return area;
        }
</code></pre>
<pre><code class="language-c#">        public double CalculateAreaExtern(double ampere, double tRise)
        {
            double I = ampere;
            double TRise = tRise;
            double constantK = 0.048;
            double constantB = 0.44;
            double constantC = 0.725;
            double area;

            area = Math.Pow(I / (constantK * Math.Pow(TRise, constantB)), (1 / constantC));

            return area;
        }
</code></pre>
<p>Und nat&uuml;rlich auch f&uuml;r die <strong>Breite der Leiterbahnen</strong>. Einmal wird dabei mir Mil gerechnet und einmal mit Oz/Ft<sup>2</sup>.</p>
<pre><code class="language-c#">        public double CalculateWidthMil(double area, double thickness)
        {
            double A = area;
            double t = thickness;
            double width;

            width = A / t;

            return width;
        }
</code></pre>
<pre><code class="language-c#">        public double CalculateWidthOzFt(double area, double thickness)
        {
            double A = area;
            double t = thickness;
            double width;

            width = A / (t * 1.378);

            return width;
        }
</code></pre>
<h2 id="testing">Testing</h2>
<p>Um sicher zu stellen, dass alles funktioniert, haben wir mit Unit Tests verschiedene Methoden und Klassen getestet. 
Zum einen wurde der Calculator getestet, die Pr&auml;fixe wurden getestet und es wurden Tests mit ultimativen Zahlen gemacht. 
Zudem wurde, dass der Unit Tree funktioniert, bereits in der Klasse selbst &uuml;berpr&uuml;ft.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
